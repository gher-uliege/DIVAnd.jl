<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DIVAnd.jl documentation · DIVAnd</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DIVAnd</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DIVAnd.jl documentation</a><ul class="internal"><li><a class="tocitem" href="#API-refence"><span>API refence</span></a></li><li><a class="tocitem" href="#Internal-API-or-advanced-usage"><span>Internal API or advanced usage</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Performance-considerations"><span>Performance considerations</span></a></li><li><a class="tocitem" href="#Debugging-message"><span>Debugging message</span></a></li><li><a class="tocitem" href="#Correlation-length"><span>Correlation length</span></a></li><li><a class="tocitem" href="#Integrating-different-datasets"><span>Integrating different datasets</span></a></li><li><a class="tocitem" href="#Frequently-asked-questions"><span>Frequently asked questions</span></a></li><li><a class="tocitem" href="#API-changes"><span>API changes</span></a></li><li><a class="tocitem" href="#Information-for-developers"><span>Information for developers</span></a></li><li><a class="tocitem" href="#Troubleshooting"><span>Troubleshooting</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DIVAnd.jl documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DIVAnd.jl documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gher-ulg/DIVAnd.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>DIVAnd</p><h1 id="DIVAnd.jl-documentation"><a class="docs-heading-anchor" href="#DIVAnd.jl-documentation">DIVAnd.jl documentation</a><a id="DIVAnd.jl-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#DIVAnd.jl-documentation" title="Permalink"></a></h1><h2 id="API-refence"><a class="docs-heading-anchor" href="#API-refence">API refence</a><a id="API-refence-1"></a><a class="docs-heading-anchor-permalink" href="#API-refence" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.diva3d" href="#DIVAnd.diva3d"><code>DIVAnd.diva3d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dbinfo = diva3d(xi,x,value,len,epsilon2,filename,varname)</code></pre><p>Create a 3D analysis (or a series of 3D analysis) with DIVAnd using the observations <code>value</code> (vector) at the locations <code>x</code> (tuple of vectors) onto the regular grid defined by the vectors <code>xi</code> using the scaled observational error variance <code>epsilon2</code> and the correlation length <code>len</code>. The result will be saved in the netCDF file <code>filename</code> under the variable <code>varname</code>.</p><p><strong>Inputs</strong></p><ul><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>value</code>: value of the observations</p></li><li><p><code>len</code>: tuple with n elements. Every element represents the correlation length.  If <code>fitcorrlen</code> is <code>false</code> (default), the correlation length should be expressed in meters.  If <code>fitcorrlen</code> is <code>true</code>, then <code>len</code> can be the empty tuple <code>()</code> or a tuple containing  3 arrays of normalized correlation lengths which will be multiplied by the  horizontal and vertical correlation lengths.</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field).</p></li></ul><p><code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a different error variance and their errors are decorrelated) or a matrix (all observations can have a different error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p><ul><li><p><code>filename</code>: The output netCDF filename.</p></li><li><p><code>varname</code>: The name of the variable (used in the netCDF file).</p></li></ul><p><strong>Optional input arguments:</strong></p><ul><li><code>bathname</code>: path to the netCDF bathymetry (default ../../DIVAnd-example-data/Global/Bathymetry/gebco<em>30sec</em>16.nc relative to this source file)</li><li><code>bathisglobal</code>: true (default) is the bathymetry is a global data set</li><li><code>plotres</code>: Call-back routine for plotting ((timeindex,sel,fit,erri) -&gt; nothing)</li><li><code>timeorigin</code>: Time origin (default DateTime(1900,1,1,0,0,0))</li><li><code>moddim</code>: modulo for cyclic dimension (vector with n elements).    Zero is used for non-cyclic dimensions. Halo points should    not be included for cyclic dimensions. For example if the first dimension    is cyclic, then the grid point corresponding to <code>mask[1,j]</code> should be    between <code>mask[end,1]</code> (left neighbor) and <code>mask[2,j]</code> (right neighbor). The default is [0,0,0],</li><li><code>zlevel</code>: <code>:surface</code> (default) for surface analysis and <code>:floor</code> for analysis from the bottom floor.</li><li><code>ncvarattrib</code>: dictionary of netCDF variable attributes.</li><li><code>ncglobalattrib</code>: dictionary of netCDF global attributes.</li><li><code>transform</code>: Anamorphosis transformation function (default: <code>Anam.notransform()</code>).</li><li><code>fitcorrlen</code>: true if the correlation length is determined from the observation (default <code>false</code>).    Note that the parameter <code>len</code> is interpreted differently when <code>fitcorrlen</code> is set to <code>true</code>.</li><li><code>fithorzcorrlen</code>: true if the horizontal correlation length is determined from the observation (default: the value of <code>fitcorrlen</code>)    Note that the parameter <code>len</code> is interpreted differently when <code>fithorzcorrlen</code> is set to <code>true</code>.</li><li><code>fitvertcorrlen</code>: true if the vertical correlation length is determined from the observation (default: the value of <code>fitcorrlen</code>)    Note that the parameter <code>len</code> is interpreted differently when <code>fitvertcorrlen</code> is set to <code>true</code>.</li><li><code>fithorz_param</code>: dictionary with additional optional parameters for <code>fithorzlen</code>, for example: <code>Dict(:smoothz =&gt; 200., :searchz =&gt; 50.)</code>.</li><li><code>fitvert_param</code>: dictionary with additional optional parameters for <code>fitvertlen</code>.</li><li><code>distfun</code>: function to compute the distance (default <code>(xi,xj) -&gt; DIVAnd.distance(xi[2],xi[1],xj[2],xj[1])</code>).</li><li><code>mask</code>: if different from <code>nothing</code>, then this mask overrides land-sea mask based on the bathymetry</li></ul><p>(default <code>nothing</code>).</p><ul><li><code>background</code>: if different from <code>nothing</code>, then this parameter allows one</li></ul><p>to load the background from a call-back function (default <code>nothing</code>). The call-back functions has the parameters <code>(x,n,trans_value,trans)</code> where <code>x</code> represent the position of the observations, <code>n</code> the time index, <code>trans_value</code>, the observations (possibly transformed) and <code>trans</code> the transformation function. The output of this function is the gridded background field and the observations minus the background field.</p><ul><li><code>background_epsilon2_factor</code>: multiplication for <code>epsilon2</code> when computing a  vertical profile as a background estimate (default: computed internally based on the amount of data). This parameter is not used  when the parameter <code>background</code> or <code>background_lenz</code> is provided.</li><li><code>background_lenz</code>: vertical correlation for background computation (default 20 m). This parameter is not used  when the parameter <code>background</code> is provided.</li><li><code>background_len</code>: deprecated option replaced by <code>background_lenz</code>.</li><li><code>filterbackground</code>: number of iterations to filter the background profile (default 0, no filtering)</li><li><code>memtofit</code>: keyword controlling how to cut the domain depending on the memory   remaining available for inversion. It is not the total memory (default 3). Use a large value (e.g. 100) to force the   usage for the more efficient direct solver if you are not limited by the amount of RAM memory.</li><li><code>minfield</code>: if the analysed field is below <code>minfield</code>, its value is replace by <code>minfield</code> (default -Inf, i.e. no substitution is done).</li><li><code>maxfield</code>: if the analysed field is above <code>maxfield</code>, its value is replace by <code>maxfield</code> (default +Inf, i.e. no substitution is done).</li><li><code>saveindex</code>: controls if just a subset of the analysis should be saved to   the netCDF file. Per default, <code>saveindex</code> is <code>(:,:,:)</code> (corresponding to   longitude, latitude and depth indices) meaning that everything is saved.   If however, for example the first layer should not be saved then <code>saveindex</code>   should be <code>(:,:,2:length(depthr))</code> where <code>depthr</code> is the 3rd element of <code>xi</code>.</li><li><code>niter_e</code>: Number of iterations to estimate the optimal scale factor of  <code>epsilon2</code> using Desroziers et al. 2005 (doi: 10.1256/qj.05.108). The default   is 1 (i.e. no optimization is done).</li><li><code>coeff_derivative2</code> (vector of 3 floats): for every dimension where this value is non-zero, an additional term is added to the cost function penalizing the second derivative. A typical value of this parameter is <code>[0.,0.,1e-8]</code>.</li><li><code>surfextend</code>: create an additional layer on top of the surface layer so that the effective background error variance is more similar to the deep ocean.  <code>false</code> is the default value.</li><li><code>stat_per_timeslice</code> (default false): if true, then the residual values (and possibly qcvalues) are also returned by time slices which is useful if the time slices overlap (see example below).</li><li><code>error_thresholds</code> (default <code>[(&quot;L1&quot;, 0.3), (&quot;L2&quot;, 0.5)]</code>). This is a list of tuples with the applied error thresholds and the variable names suffixes. If the variable is named e. g. <code>&quot;Salinity&quot;</code>, then the variables <code>&quot;Salinity_L1&quot;</code> (resp.  <code>&quot;Salinity_L2&quot;</code>) will be created where the analysis is masked if the relative error exceeds 0.3 (resp. 0.5).</li></ul><p>Any additional keywoard arguments understood by <code>DIVAndgo</code>/<code>DIVAndrun</code> can also be used here (e.g. velocity constrain)</p><p>The output is a dictionary with the followings keys:</p><ul><li><code>:residuals</code>: the difference between the observations and the analysis (interpolated linearly to the</li></ul><p>location of the observations). The residual is <code>NaN</code> if the observations are not within the domain as defined by the mask and the coordinates of the observations <code>x</code>.</p><ul><li><code>:qcvalues</code>: quality control scores (if activated)</li></ul><p><strong>Example</strong></p><p>Example on how to aggredate the residuals per time slice and to retain the maximum residual:</p><pre><code class="language-julia">selection_per_timeslice = dbinfo[:selection_per_timeslice]
residuals_per_timeslice = dbinfo[:residuals_per_timeslice]
selection_per_timeslice = dbinfo[:selection_per_timeslice]

max_residuals = fill(-Inf,length(value))
for n = 1:length(selection_per_timeslice)
   sel = selection_per_timeslice[n]
   max_residuals[sel] = max.(max_residuals[sel],residuals_per_timeslice[n])
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>At all vertical levels, there should at least one sea point.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/diva.jl#L1-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAndrun" href="#DIVAnd.DIVAndrun"><code>DIVAnd.DIVAndrun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DIVAndrun(mask,pmn,xi,x,f,len,epsilon2; &lt;keyword arguments&gt;)</code></pre><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p><strong>Input:</strong></p><ul><li><code>mask</code>: binary mask delimiting the domain. true is inside and false outside.</li></ul><p>For oceanographic application, this is the land-sea mask where sea is true and land is false.</p><ul><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every  element represents the scale factor of the corresponding dimension. Its  inverse is the local resolution of the grid in a particular dimension.  For example, in two dimensions, <code>pmn</code> is a tuple <code>(pm,pn)</code> where <code>pm</code> is  the inverse of the local resolution in first dimension and <code>pn</code> is the the inverse  of the local resolution in second dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated.</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations.</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (vector of <code>m</code> elements where <code>m</code> is the number of observations). See also note.</p></li><li><p><code>len</code>: tuple with n elements. Every element represents the correlation length for a given dimension.</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a different error variance and their errors are decorrelated) or a matrix (all observations can have a different error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li></ul><p><strong>Optional input arguments specified as keyword arguments</strong></p><ul><li><p><code>velocity</code>: velocity of the advection constraint. It is a tuple of n arrays and each array represents a single velocity component. The individual array should have the same size as the final grid. The first (second,..) element of the velocity is the velocity compomenent along the first (second,...) dimension. The <code>velocity</code> has the units of a length-scale. If this parameter is derived from ocean currents, then the later must be multiplied by a factor (to be determined for example by cross-validation) and this factor has the units of a time-scale. The default is no-advection constraint.</p></li><li><p><code>alpha</code>: alpha is vector of coefficients multiplying various terms in the      cost function. The first element multiplies the norm.      The other i-th element of alpha multiplies the (i+1)-th derivative.      Per default, the highest derivative is m = ceil(1+neff/2) where neff is the      effective dimension of the problem (the number of dimensions with a nonzero      correlation length) and <code>ceil</code> is the ceiling function (rounding up).</p></li></ul><pre><code class="language-none">   The values of alpha is the (m+1)th row of the Pascal triangle:
      m=0         1
      m=1       1   1
      m=1     1   2   1     (n=1,2)
      m=2   1   3   3   1   (n=3,4)
      ...</code></pre><ul><li><p><code>constraints</code>: a structure with user specified constraints (see <code>DIVAnd_addc</code>).</p></li><li><p><code>moddim</code>: modulo for cyclic dimension (vector with n elements).    Zero is used for non-cyclic dimensions. One should not include a boundary    zone (sometimes called a ghost zone or halo) for cyclic dimensions.    For example if the first dimension    is cyclic, then the grid point corresponding to <code>mask[1,j]</code> should be    between <code>mask[end,j]</code> (left neighbor) and <code>mask[2,j]</code> (right neighbor).</p></li><li><p><code>fracindex</code>: fractional indices (n-by-m array). If this array is specified,    then x and xi are not used.</p></li><li><p><code>inversion</code>: direct solver (:chol for Cholesky factorization) or an    interative solver (:pcg for preconditioned conjugate gradient [1]) can be    used.</p></li><li><p><code>compPC</code>: function that returns a preconditioner for the primal formulation    if inversion is set to &#39;pcg&#39;. The function has the following arguments:</p><pre><code class="language-none">     fun = compPC(iB,H,R)</code></pre><p>where iB is the inverse background error covariance, H the observation   operator and R the error covariance of the observation. The function <code>compPC</code> returns the   preconditioner <code>fun(x,fx)</code> computing fx = <code>M \ x</code> (the inverse of M times x)   where <code>M</code> is a positive defined symmetric matrix [1].   Effectively, the system E⁻¹ A (E⁻¹)ᵀ (E x) = E⁻¹ b is solved for (E x) where E Eᵀ = M.   Ideally, M should this be similar to A, so that E⁻¹ A (E⁻¹)ᵀ is close to the identity matrix.</p></li><li><p><code>fi0</code>: starting field for iterative primal algorithm (same size as <code>mask</code>).</p></li><li><p><code>f0</code>: starting field for iterative dual algorithm (same size as the observations <code>f</code>).</p></li><li><p><code>operatortype</code>: Val{:sparse} for using sparse matrices (default) or Val{:MatFun} or using functions   to define the constrains.</p></li><li><p><code>scale_len</code>: true (default) if the correlation length-scale should be scaled   such that the analytical   kernel reaches 0.6019072301972346 (besselk(1.,1.)) at the same distance   than in 2D. The kernel behaves thus similar to   the default kernel in two dimensions (alpha = [1,2,1]).</p></li><li><p><code>alphabc</code>: numerical value defining how the last grid points are stretched outward.  If <code>alphabc</code> is 1, the default value mimics an infinite domain.  To have previous behaviour of finite domain use alphabc equal to <code>0</code>.</p></li><li><p><code>btrunc</code>: if provided defines where to truncate the calculation of the   covariance matrix B. Only values up and including alpha[btrunc] will be   calculated. If the iterative solution is calculated, the missing terms will   be calculated on the fly during the conjugate gradient calculations.    Default value is none and full covariance calculation.</p></li></ul><p><strong>Output:</strong></p><ul><li><code>fi</code>: the analysed field</li><li><code>s</code>: a structure with an array <code>s.P</code> representing the analysed error covariance</li></ul><p><strong>Note:</strong></p><p>If zero is not a valid first guess for your variable (as it is the case for   e.g. ocean temperature), you have to subtract the first guess from the   observations before calling DIVAnd and then add the first guess back in.</p><p><strong>Example:</strong></p><p>see DIVAnd<em>simple</em>example.jl</p><p><strong>References</strong></p><p>[1]  https://en.wikipedia.org/w/index.php?title=Conjugate<em>gradient</em>method&amp;oldid=761287292#The<em>preconditioned</em>conjugate<em>gradient</em>method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAndrun.jl#L159-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAndgo" href="#DIVAnd.DIVAndgo"><code>DIVAnd.DIVAndgo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fi, erri, residuals, qcvalues, scalefactore = DIVAndgo(mask,pmn,xi,x,f,len,epsilon2,errormethod; ...);</code></pre><p><strong>Input:</strong></p><ul><li>Same arguments as DIVAndrun with in addition</li><li><code>errormethod</code> :   you have the choice between <code>:cpme</code> (clever poorman&#39;s method, default method if parameter not provided), <code>:none</code> or <code>:exact</code> (only available if windowed analysis are done with DIVAndrun)</li><li><code>MEMTOFIT=</code>: keyword controlling how to cut the domain depending on the memory remaining available for inversion (not total memory)</li><li><code>RTIMESONESCALES=</code> : if you provide a tuple of length scales, data are weighted differently depending on the numbers of neighbours they have. See <code>weight_RtimesOne</code> for details</li><li><code>QCMETHOD=</code> : if you provide a qc method parameter, quality flags are calculated. See <code>DIVAnd_cv</code> for details</li><li><code>solver</code> (default <code>:auto</code>:). :direct for the direct solver or :auto for automatic choice between the direct solver or the iterative solver.</li><li><code>overlapfactor</code> : describes how many times the length scale is used for the overlapping. default is 3.3. use lower values ONLY for very good data coverage.</li></ul><p><strong>Output:</strong></p><ul><li><code>fi</code>: the analysed field</li><li><code>erri</code>: relative error field on the same grid as fi. () if errormethod is fixed to <code>:none</code></li><li><code>residuals</code>: array of residuals at data points. For points not on the grid or on land: <code>NaN</code></li><li><code>qcvalues</code>: if <code>QCMETHOD=</code> is provided, the output array contains the quality flags otherwise qcvalues is (). For points on land or not on the grid: 0</li><li><code>scalefactore</code>: Desroziers et al. 2005 (doi: 10.1256/qj.05.108) scale factor for <code>epsilon2</code></li></ul><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p>IMPORTANT: DIVAndgo is very similar to DIVAndrun and is only interesting to use if DIVAndrun cannot fit into memory or if you want to parallelize. (In the latter case do not forget to define the number of workers; see <code>addprocs</code> for example)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAndgo.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_averaged_bg" href="#DIVAnd.DIVAnd_averaged_bg"><code>DIVAnd.DIVAnd_averaged_bg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fma,faanom = DIVAnd_averaged_bg(mask,pmn,xi,x,f,len,epsilon2,toaverage;moddim=[])</code></pre><p><strong>Input:</strong></p><p>As for DIVAndrun, including all dimensions before averaging</p><p><strong>additional argument:</strong></p><ul><li>toaverage: Array of ndims of boolean telling if in the corresponding direction averaging must be done</li></ul><p><strong>Presently NO optional arguments from DIVAndrun supported except moddim</strong></p><p><strong>Output:</strong></p><ul><li>fma: Analysis where in the directions where toaverage is true, the same value is found</li><li>faanom: Data anomalies when the analysis is subtracted from the input field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_averaged_bg.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.SDNMetadata" href="#DIVAnd.SDNMetadata"><code>DIVAnd.SDNMetadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncglobalattrib,ncvarattrib = SDNMetadata(metadata,fi)</code></pre><p>Based on the information in the dictionary <code>metadata</code> and the analysed 4D field <code>fi</code> produce a list of NetCDF global and variable attributes for <code>DIVAnd_save2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/SDNMetadata.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.save" href="#DIVAnd.save"><code>DIVAnd.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save(filename,xyi,fi,varname;
                      ncvarattrib = Dict(), ncglobalattrib = Dict(), ...)</code></pre><p>Save the result of the analysis in a netCDF file.</p><p><strong>Input arguments</strong></p><ul><li><code>filename</code>: the name of the NetCDF file</li><li><code>xyi</code>: tuple with n vectors. Every element in this tuple represents a coordinate of the final grid on which the observations are interpolated</li><li><code>fi</code>: the analysed field</li><li><code>varname</code>: the name of the NetCDF variable</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>ncglobalattrib</code>: a dictionary with the global attributes</li><li><code>ncvarattrib</code>: a dictionary with the variable attributes</li><li><code>relerr</code>: relative error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_save.jl#L390-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.loadbigfile" href="#DIVAnd.loadbigfile"><code>DIVAnd.loadbigfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">value,lon,lat,depth,time,obsid = loadbigfile(filename)</code></pre><p>Load data from the text file <code>filename</code> and returns vectors with the value, longitude, latitude, depth and time (as DateTime). A list string identifiers is also returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/load_obs.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.checkobs" href="#DIVAnd.checkobs"><code>DIVAnd.checkobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">checkobs(x,v,ids)
checkobs(io::IO,x,v,ids)</code></pre><p>Print some basic information about the coordinates <code>x</code> (tuple of vector) and values <code>v</code> (vector) having the identifier <code>ids</code> (vector of strings) to check erroneous data. It prints wheter NaNs or Infs are found and the minimum and maximum value.</p><p>If the argument <code>io</code> is provided, the information is input/output stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/obsstat.jl#L61-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.smoothfilter" href="#DIVAnd.smoothfilter"><code>DIVAnd.smoothfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ff = smoothfilter(x,f,scale)</code></pre><p>Smooth the function <code>f</code> defined on <code>x</code> by solving the diffusion equation</p><p>∂ₜ ϕ = ν ∂²ₓ ϕ</p><p><code>scale</code> is the spatial scales of the removed length-scales. It is defined as 2Tν  where T is the integration time.</p><p>It uses the Greens functions for 1D diffusion: 1/sqrt(4 π ν t) * exp(-x^2 / (4νt))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L546-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Anam.loglin" href="#DIVAnd.Anam.loglin"><code>DIVAnd.Anam.loglin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trans,invtrans = loglin(t; epsilon = 0.)</code></pre><p>Provide the following transform <code>log(x + epsilon)</code> (for x &lt; t) and its inverse. Beyond the threshold <code>t</code> (x ≥ t), the function is extended linearly in a continous way.</p><p><code>trans</code>,<code>invtrans</code> are scalar functions such that for any <code>x</code> (x &gt; epsilon), <code>x == invtrans(trans(x))</code>.</p><p>For any array <code>X</code>, we have: <code>X == invtrans.(trans.(X))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/anamorphosis.jl#L16-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Anam.logit" href="#DIVAnd.Anam.logit"><code>DIVAnd.Anam.logit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trans,invtrans = logit(; min = 0., max = 1.)</code></pre><p>Provide the logit transform and its inverse. Per default the logit transform maps values within the interval from 0 and 1. This can be changed with the <code>min</code> and <code>max</code> parameters. Note that trans(min) = -∞ and trans(max) = +∞. The use safety-margin might be necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/anamorphosis.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.divadoxml" href="#DIVAnd.divadoxml"><code>DIVAnd.divadoxml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DIVAnd.divadoxml(filepath,varname,project,cdilist,xmlfilename;
                 ignore_errors = false,
                 WMSlayername = [],
                 previewindex = 1,
                 additionalcontacts = [],
                 additionalvars = Dict{String,Any}())</code></pre><p>Generate the XML metadata file <code>xmlfilename</code> from the NetCDF file <code>filepath</code> (or list of files) with the  NetCDF variable <code>varname</code>. Project is either &quot;SeaDataNet&quot;, &quot;EMODNET-chemistry&quot; or &quot;SeaDataCloud&quot;. <code>cdilist</code> is the file from https://emodnet-chemistry.maris.nl/download/export.zip.</p><p>The XML file contains a list of the data the originators. divadoxml will abort with an error if some combinations of EDMO code, local CDI ID are not present in the <code>cdilist</code>. Such errors can be ignored if <code>ignore_errors</code> is set to true.</p><p>Information can be overridden with the dictionary <code>additionalvars</code>. The keys should corresponds to the template tags found the in <code>template</code> directory. Template tags are the strings inside {{ and }}.</p><p>NetCDF_URL should be suppplied since it&#39;s a URL of a ZIP file which is usually not from OceanBrowser.</p><p>If <code>filepath</code> is a vector of file names, the argument <code>WMSlayername</code> can be provided to give additional information to distinguish between the NetCDF files. The elements of the vector of string will be appended to the description of the WMS layer.</p><p>The resulting XML file includes the file names (provided by <code>filepath</code>). Do not change the file names after running this function, otherwise the XML will still contain a reference to the old file names. If you must change the file names please do so before running this script.</p><p>If the data is present in a subfolder (e.g. &quot;Winter&quot;) later on the OceanBrowser webserver, the <code>filepath</code> should also contain this subfolder (e.g. &quot;Winter/somefile.nc&quot;). The local directories should mirror the directory structure on OceanBrowser. Relative paths should be used, and if the Julia code isn&#39;t right above the NetCDF files, use cd(&quot;&lt;path&gt;&quot;) before each setting the files parameter which use paths relative to this path.</p><p><code>additionalcontacts</code> is a list of dictionaries with additional condact information to be added in the XML file. Elements are typically create by the function <code>DIVAnd.getedmoinfo</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">download(&quot;https://emodnet-chemistry.maris.nl/download/export.zip&quot;,&quot;export.zip&quot;)
files = [
         &quot;Winter (January-March) - 6-year running averages/Water_body_chlorophyll-a.4Danl.nc&quot;,
         &quot;Spring (April-June) - 6-year running averages/Water_body_chlorophyll-a.4Danl.nc&quot;,
         &quot;Summer (July-September) - 6-year running averages/Water_body_chlorophyll-a.4Danl.nc&quot;,
         &quot;Autumn (October-December) - 6-year running averages/Water_body_chlorophyll-a.4Danl.nc&quot;
         ];

additionalcontacts = [
    DIVAnd.getedmoinfo(1977,&quot;originator&quot;), # US NODC for World Ocean Database
    DIVAnd.getedmoinfo(4630,&quot;originator&quot;), # CORIOLIS for CORA
]

DIVAnd.divadoxml(files,&quot;Water_body_chlorophyll-a&quot;,&quot;EMODNET-chemistry&quot;,&quot;export.zip&quot;,&quot;test.xml&quot;;
    ignore_errors = true,
    additionalvars = Dict(&quot;abstract&quot; =&gt; &quot;Here goes the abstract&quot;),
    additionalcontacts = additionalcontacts,
    WMSlayername = [&quot;winter&quot;,&quot;spring&quot;,&quot;summer&quot;,&quot;autumn&quot;]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/SDNMetadata.jl#L917-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.getedmoinfo" href="#DIVAnd.getedmoinfo"><code>DIVAnd.getedmoinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contact = DIVAnd.getedmoinfo(edmo_code,role)</code></pre><p>Returns a dictionary with the contact information from the EDMO registry based on the prodivided <code>emdo_code</code>. <code>role</code> is the Sextant contact information role, i.e. either &quot;originator&quot; or &quot;author&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/SDNMetadata.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.random" href="#DIVAnd.random"><code>DIVAnd.random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">field = DIVAnd.random(mask,pmn,len,Nens)</code></pre><p>Create <code>Nens</code> random fields with the correlation length <code>len</code> in a domain with the mask <code>mask</code> and the metric <code>pmn</code>.</p><p>See <code>DIVAnd.DIVAndrun</code> for more information about these parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L576-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.distance" href="#DIVAnd.distance"><code>DIVAnd.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">d = distance(lat1,lon1,lat2,lon2)</code></pre><p>Compute the great-circle distance between the points (<code>lat1,</code>lon1<code>) and (</code>lat2,<code>lon2</code>). The units of all input and output parameters are degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_metric.jl#L2-L7">source</a></section><section><div><pre><code class="language-none">d = distance([lon1,lat1],[lon2,lat2])</code></pre><p>The same as <code>distance(lat1,lon1,lat2,lon2)</code> but there the arguments are vectors and the order is longitude then latitude.</p><p>The units of all input and output parameters are degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_metric.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.interp" href="#DIVAnd.interp"><code>DIVAnd.interp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f = interp(xi,fi,x)</code></pre><p>Interpolate field <code>fi</code> (n-dimensional array) defined at <code>xi</code> (tuble of n-dimensional arrays or vectors) onto grid <code>x</code> (tuble of n-dimensional arrays). The grid in <code>xi</code> must be align with the axis (e.g. produced by DIVAnd.ndgrid).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L668-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.backgroundfile" href="#DIVAnd.backgroundfile"><code>DIVAnd.backgroundfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fun = backgroundfile(fname,varname)</code></pre><p>Return a function <code>fun</code> which is used in DIVAnd to make anomalies out of observations based relative to the field defined in the NetCDF variable <code>varname</code> in the NetCDF file <code>fname</code>. It is assumed that the NetCDF variables has the variable <code>lon</code>, <code>lat</code> and <code>depth</code>. And that the NetCDF variable is defined on the same grid as the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L684-L694">source</a></section><section><div><pre><code class="language-none">fun = backgroundfile(fname,varname,TS)</code></pre><p>Return a function <code>fun</code> which is used in DIVAnd to make anomalies out of observations based relative to the field defined in the NetCDF variable <code>varname</code> in the NetCDF file <code>fname</code>. It is assumed that the NetCDF variables has the variable <code>lon</code>, <code>lat</code> and <code>depth</code>. And that the NetCDF variable is defined on the same grid as the analysis and was generated according to the provided time selector <code>TS</code> (TimeSelectorYearListMonthList or TimeSelectorRunningAverage).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>At all vertical levels, there should at least one sea point.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L718-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.checkduplicates" href="#DIVAnd.Quadtrees.checkduplicates"><code>DIVAnd.Quadtrees.checkduplicates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dupl = checkduplicates(x,value,delta,deltavalue)</code></pre><p>Based on the coordinates <code>x</code> (a tuple of longitudes <code>lons</code>, latitudes <code>lats</code>, depths (<code>zs</code>) and times (<code>times</code> vector of <code>DateTime</code>)), search for points which are in the same spatio-temporal bounding  box of length <code>delta</code>. <code>delta</code> is a vector with 4 elements corresponding to longitude, latitude, depth and time (in days). <code>dupl</code> a vector of vectors containing the indices of the duplicates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L512-L520">source</a></section><section><div><pre><code class="language-none">dupl = checkduplicates(x1,value1,x2,v2,value2,delta,deltavalue)</code></pre><p>Report duplicates of observations in data set (x2,v2) which are also in data set (x1,v1). <code>x1</code> and <code>x2</code> are tuples of vectors with the coordinates, <code>v1</code> and <code>v2</code> are the corresponding values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L599-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_heatmap" href="#DIVAnd.DIVAnd_heatmap"><code>DIVAnd.DIVAnd_heatmap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes a  heatmap based on locations of observations using kernel density estimation (probability density field whose integral over the domain is one)</p><p>dens,Ltuple,LCV,LSCV = DIVAnd_heatmap(mask,pmn,xi,x,inflation,Labs;Ladaptiveiterations=0,myheatmapmethod=&quot;DataKernel&quot;,     optimizeheat=true,nmax=1000,otherargs...)</p><p><strong>Input:</strong></p><ul><li><p><code>mask</code>: mask as usual</p></li><li><p><code>pmn</code> : tuple of metrics as usual</p></li><li><p><code>xi</code>: tuple of coordinates of the grid for the heatmap</p></li><li><p><code>x</code> : tuple of coordinates of observations</p></li><li><p><code>inflation</code>: array generally of ones. For some applications an observation can carry a different weight which is then encoded in the array</p></li><li><p><code>Labs</code> : the length scales for DIVAnd. Here their meaning is the spread (bandwidth) of the observations for the Kernel calculation</p></li><li><pre><code class="language-none">         if zero is provided, the routine applies an empirical estimate, returned in the Ltuple output.</code></pre></li><li><p><code>Ladaptiveiterations</code>: adaptive scaling where the length scales are adapted on the data density already estimated. You can iterate. Default &quot;0&quot;</p></li><li><p><code>optimizeheat</code> : boolean which can turn on or off an algorithmic optimisation. Results should be identical. Default is to optimize</p></li><li><p><code>myheatmapmethod</code>: can be &quot;Automatic&quot;, &quot;GridKernel&quot; or &quot;DataKernel&quot; (Results should be very similar except near boundaries)</p></li><li><p><code>nmax</code>: maximum number of data points. If actual data size is larger, approximatively nmax superobservations are calculated and a warning issued.</p></li><li><p><code>otherargs...</code>: all other optional arguments DIVAndrun can take (advection etc)</p></li></ul><p><strong>Output:</strong></p><ul><li><code>dens</code>: data density field (integral is one)</li><li><code>Ltuple</code> : The bandwidthth used (either the input value or the calculated ones)</li><li><code>LCV</code> : Likelihood Cross Validation estimator value (the higher the better) leave one out approach</li><li><code>LSCV</code> : Least Square Cross Validation estimator (the lower the better) leave one out approach</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_heatmap.jl#L1-L29">source</a></section></article><h3 id="Bathymetry-and-spatial-temporal-domain"><a class="docs-heading-anchor" href="#Bathymetry-and-spatial-temporal-domain">Bathymetry and spatial-temporal domain</a><a id="Bathymetry-and-spatial-temporal-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Bathymetry-and-spatial-temporal-domain" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.load_bath" href="#DIVAnd.load_bath"><code>DIVAnd.load_bath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xi,yi,bath = DIVAnd.load_bath(bath_name,isglobal,xi,yi)</code></pre><p>Load the bathymetry from the netCDF file <code>bathname</code>. The parameter <code>isglobal</code> is true if the NetCDF file covers the whole globe and thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> are vectors containing the longitude and latitude grid onto which the bathymetry should be interpolated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/load_mask.jl#L109-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.extract_bath" href="#DIVAnd.extract_bath"><code>DIVAnd.extract_bath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bx,by,b = DIVAnd.extract_bath(bath_name,isglobal,xi,yi)</code></pre><p>Extract the bathymetry from the NetCDF file <code>bathname</code>. The parameter <code>isglobal</code> is true if the NetCDF file covers the whole globe and thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> are vectors defining the bounding box of the data. No interpolation is performed.</p><p><strong>Convention:</strong> b is positive in the water and negative in the air.</p><p>The NetCDF file is expected to have the one dimensional variables <code>lon</code> and <code>lat</code> with the longitude (degrees East) and latitude (degrees North) and the two dimentional array <code>bat</code> with the digital terrain model (negative in water and positive above water). The order of the dimension should follow be: longitude and then latitude in <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">Column-major ordering</a> (or latitude and then longitude if the tool <code>ncdump</code> is used, which is based on Row-major ordering).</p><p>Example of the output of <code>ncdump -h</code>:</p><pre><code class="language-none">netcdf gebco_30sec_8 {
dimensions:
     lat = 2702 ;
     lon = 5400 ;
variables:
     double lat(lat) ;
          lat:long_name = &quot;Latitude&quot; ;
          lat:standard_name = &quot;latitude&quot; ;
          lat:units = &quot;degrees_north&quot; ;
     double lon(lon) ;
          lon:long_name = &quot;Longitude&quot; ;
          lon:standard_name = &quot;longitude&quot; ;
          lon:units = &quot;degrees_east&quot; ;
     float bat(lat, lon) ;
          bat:long_name = &quot;elevation above sea level&quot; ;
          bat:standard_name = &quot;height&quot; ;
          bat:units = &quot;meters&quot; ;

// global attributes:
          :title = &quot;GEBCO&quot; ;
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/load_mask.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.load_mask" href="#DIVAnd.load_mask"><code>DIVAnd.load_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xi,yi,mask = load_mask(bath_name,isglobal,xi,yi,level::Number)</code></pre><p>Generate a land-sea mask based on the topography from the NetCDF file <code>bathname</code>. The parameter <code>isglobal</code> is true if the NetCDF file covers the whole globe and thus the last longitude point can be considered to be right next to the first longitude point. <code>xi</code> and <code>yi</code> are vectors containing the longitude and latitude grid onto which the bathymetry should be interpolated.</p><p><strong>Convention:</strong> in the water, <code>level</code> is positive and in the air <code>level</code> is negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/load_mask.jl#L152-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_metric" href="#DIVAnd.DIVAnd_metric"><code>DIVAnd.DIVAnd_metric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pm,pn = DIVAnd_metric(lon,lat)</code></pre><p>Compute metric scale factors <code>pm</code> and <code>pn</code> based on the arrays longitude <code>lon</code> and latitude <code>lat</code>. The variables pm and pn represent the inverse of the local resolution in meters using the mean Earth radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_metric.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.domain" href="#DIVAnd.domain"><code>DIVAnd.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mask,(pm,pn),(xi,yi) = domain(bathname,bathisglobal,lonr,latr)</code></pre><p>Generate a 2D geospatial domain based on the topography from the netCDF file <code>bathname</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/domain.jl#L69-L74">source</a></section><section><div><pre><code class="language-none">mask,(pm,pn,po),(xi,yi,zi) = domain(bathname,bathisglobal,lonr,latr,depthr)</code></pre><p>Generate a 3D geospatial domain based on the topography from the netCDF file <code>bathname</code>. If <code>zlevel</code> is <code>:surface</code>, then <code>depthr</code> is zero for the sea surface and positive in water (positive is down). If <code>zlevel</code> is <code>:floor</code>, then <code>depthr</code> is zero for the sea floor and positive in water (positive is up)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/domain.jl#L85-L92">source</a></section><section><div><pre><code class="language-none">mask,(pm,pn,po,pp),(xi,yi,zi,ti) = domain(bathname,bathisglobal,lonr,latr,depthr,timer)</code></pre><p>Generate a geospatial domain based on the topography from the netCDF file <code>bathname</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/domain.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_rectdom" href="#DIVAnd.DIVAnd_rectdom"><code>DIVAnd.DIVAnd_rectdom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mask,pmn,xyi = DIVAnd_rectdom(coord1,coord2,...)</code></pre><p>Create a &quot;rectangular&quot; domain in <code>n</code> dimensions with the coordinates <code>coord1</code> <code>coord2</code>... assuming a Catersian metric. This functions returns the mask <code>mask</code>, the coordinates <code>(xi,yi,...)</code> and the metric <code>(pm,pn...)</code>.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; mask,(pm,pn),(xi,yi) = DIVAnd_rectdom(range(0,stop=1,length=50),linspace(0,stop=1,length=50))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/domain.jl#L41-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_squaredom" href="#DIVAnd.DIVAnd_squaredom"><code>DIVAnd.DIVAnd_squaredom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mask,pmn,xyi = DIVAnd_squaredom(n,coord)</code></pre><p>Create a &quot;square&quot; domain in <code>n</code> dimensions with the coordinates <code>coord</code> assuming a Cartesian metric. This functions returns the mask <code>mask</code>, the coordinates <code>(xi,yi,...)</code> and the metrics <code>(pm,pn...)</code>.</p><p><strong>Example</strong></p><p>mask,(pm,pn),(xi,yi) = DIVAnd_squaredom(2,range(0,stop=1,length=50))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/domain.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.TimeSelectorYW" href="#DIVAnd.TimeSelectorYW"><code>DIVAnd.TimeSelectorYW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TS = TimeSelectorYW(years,yearwindow,monthlists)</code></pre><p>The structure <code>TS</code> handles the time aggregation based on <code>years</code> and <code>monthlists</code>. It is similar to <code>TimeSelectorYearListMonthList</code> except that the elements of <code>yearlists</code> are centred around <code>years</code> and span <code>yearwindow</code> years. <code>yearlists</code> is in fact constructed by adding and subtracting <code>yearwindow/2</code> to every element of years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/select_time.jl#L187-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.TimeSelectorYearListMonthList" href="#DIVAnd.TimeSelectorYearListMonthList"><code>DIVAnd.TimeSelectorYearListMonthList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TS = TimeSelectorYearListMonthList(yearlists,monthlists)</code></pre><p>The structure <code>TS</code> handles the time aggregation based on <code>yearlists</code> and <code>monthlists</code>. <code>yearlists</code> is a vector of ranges (containing start and end years), for example <code>[1980:1989,1990:1999,2000:2009]</code>.</p><p><code>monthlists</code> is a vector of two-element vector (containing start and end months), for example <code>[1:3,4:6,7:9,10:12]</code>.</p><p>The upper bound of a <code>yearlist</code> and <code>monthlist</code> element is considered inclusive. The range of years of 2000:2009 consideres all years upto and including the year 2009.</p><p>If a month range spans beyond December, then all Months must be specified, e.g. example <code>[2:4,5:6,7:9,[10,11,12,1]]</code> or <code>[2:4,5:6,7:9,[10:12;1]]</code>. However using <code>[2:4,5:6,7:9,10:1]</code> (bug!) will result in an empty month range.</p><p><strong>Example</strong></p><pre><code class="language-julia"># seasonal climatology using all data from 1900 to 2017
# for winter (December-February), spring, summer, autumn

TS = DIVAnd.TimeSelectorYearListMonthList([1900:2017],[[12,1,2],[3,4,5],[6,7,8],[9,10,11]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/select_time.jl#L8-L35">source</a></section></article><h3 id="Load-observations"><a class="docs-heading-anchor" href="#Load-observations">Load observations</a><a id="Load-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Load-observations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.saveobs" href="#DIVAnd.saveobs"><code>DIVAnd.saveobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DIVAnd.saveobs(filename,xy,ids;
               type_save = Float32,
               timeorigin = DateTime(1900,1,1,0,0,0),
               used = trues(size(ids)),
               )</code></pre><p>Save the location and time of the observations in the netCDF file <code>filename</code> and their identifier <code>ids</code>. <code>xy</code> is a tuple with the vectors longitude, latitude, depth and time (as a vector of <code>DateTime</code>).</p><p><strong>Optional arguments:</strong></p><ul><li><code>type_save</code>: the type to save the data (default Float32). However, the time  is always saved as <code>Float64</code>.</li><li><code>timeorigin</code>: time origin for the time units attribute (default is</li></ul><p>1900-01-01 00:00:00)</p><ul><li><code>used</code>: allows one to subset the data to save only used variables in the netCDF  file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_save.jl#L429-L447">source</a></section><section><div><pre><code class="language-none">DIVAnd.saveobs(filename,varname,value,xy,ids;
               type_save = Float32,
               timeorigin = DateTime(1900,1,1,0,0,0),
               used = trues(size(ids)),
               chunksize = 10_000,
               )</code></pre><p>Save <code>value</code> and the location and time of the observation in the NetCDF file <code>filename</code> and their identifier <code>ids</code>. <code>xy</code> is a tuple with the vectors longitude, latitude, depth and time (as a vector of <code>DateTime</code>). The values will be saved in the variable called <code>varname</code>.</p><p><strong>Optional arguments:</strong></p><ul><li><code>type_save</code>: the type to save the data (default Float32). However, the time  is always saved as <code>Float64</code>.</li><li><code>timeorigin</code>: time origin for the time units attribute (default is</li></ul><p>1900-01-01 00:00:00)</p><ul><li><code>used</code>: allows to subset the data to save only used variables in the netCDF  file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_save.jl#L577-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.loadobs" href="#DIVAnd.loadobs"><code>DIVAnd.loadobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">obsvalue,obslon,obslat,obsdepth,obstime,obsid = loadobs(T,filename,varname)</code></pre><p>Load the variable <code>varname</code> from the netCDF file <code>filename</code>. Coordinates (the netCDF variables &quot;obslon&quot;, &quot;obslat&quot;, &quot;obsdepth&quot;), time (&quot;obstime&quot;) and identifiers (&quot;obsids&quot;) will also be loaded. Numeric output arguments will have the type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/load_obs.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.NCSDN.load" href="#DIVAnd.NCSDN.load"><code>DIVAnd.NCSDN.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">obsvalue,obslon,obslat,obsdepth,obstime,obsids = load(T,
  fname,param; qualityflags = [GOOD_VALUE, PROBABLY_GOOD_VALUE])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/NCSDN.jl#L146-L151">source</a></section><section><div><pre><code class="language-none">data,lon,lat,z,time,ids = SDN.load(T,fnames,param; qualityflags = ...)</code></pre><p>Load all data in the vector of file names <code>fnames</code> corresponding to the parameter <code>param</code> as the data type <code>T</code>. Only the data with the quality flags <code>SDN.good_data</code> and <code>SDN.probably_good_data</code> are loaded per default. The output parameters correspond to the data, longitude, latitude, depth, time (as <code>DateTime</code>) and an identifier (as <code>String</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/NCSDN.jl#L228-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.NCSDN.loadvar" href="#DIVAnd.NCSDN.loadvar"><code>DIVAnd.NCSDN.loadvar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">data = loadvar(ds,param;
               fillvalue::T = NaN,
               qualityflags = [GOOD_VALUE, PROBABLY_GOOD_VALUE],
               qfname = param * QC_SUFFIX,
               )</code></pre><p>Load the netCDF variable <code>param</code> from the NCDataset <code>ds</code>. Data points not having the provide quality flags will be masked by <code>fillvalue</code>. <code>qfname</code> is the netCDF variable name for the quality flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/NCSDN.jl#L39-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.NCODV.load" href="#DIVAnd.NCODV.load"><code>DIVAnd.NCODV.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">obsvalue,obslon,obslat,obsdepth,obstime,obsids = NCODV.load(T,fname,long_name;
     qv_flags = [&quot;good_value&quot;,&quot;probably_good_value&quot;],
     nchunk = 10</code></pre><p>)</p><p>Load all profiles in the file <code>fname</code> corresponding to netCDF variable with the <code>long_name</code> attribute equal to the parameter <code>long_name</code>. <code>qv_flags</code> is a list of strings with the quality flags to be kept. <code>obsids</code> is a vector of strings with the EDMO code and local CDI id concatenated by a hyphen.</p><p><code>nchunk</code> is the number of profiles read at a time. Large values of <code>nchunk</code> can increase performance but requirer also more memory.</p><p>The variable with the following standard_name should exits:</p><ul><li>longitude</li><li>latitude</li><li>time</li></ul><p>As well as the variable with the following long_name:</p><ul><li>LOCAL<em>CDI</em>ID</li><li>EDMO<em>code or EDMO</em>CODE</li><li>Depth</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/NCODV.jl#L162-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.loaddata" href="#DIVAnd.ODVspreadsheet.loaddata"><code>DIVAnd.ODVspreadsheet.loaddata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">data = loaddata(sheet,profile,locname,fillvalue; fillmode = :repeat)</code></pre><p>Load a single column referred by the local name <code>locname</code> in the profile <code>profile</code> from the ODV spreadsheet <code>sheet</code>. Empty values are either replaced by <code>fillvalue</code> (if fillmode is :fill) or the previous value if repeated (if fillmode is :repeat)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L455-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.parsejd" href="#DIVAnd.ODVspreadsheet.parsejd"><code>DIVAnd.ODVspreadsheet.parsejd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dt = parsejd(t)</code></pre><p>Convert a Chronological Julian Day Number to a DateTime object. The reference value is taken from <a href="https://web.archive.org/web/20171129142108/https://www.hermetic.ch/cal_stud/chron_jdate.htm">Chronological Julian Date</a></p><p>From the SDN standard: &quot;A real number representing the Chronological Julian Date, which is defined as the time elapsed in days from 00:00 on January 1 st 4713 BC. ... &quot;</p><p>The time origin is <em>not</em> noon (12:00) on Monday, January 1, 4713 BC as for the Julia Date Number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L382-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.myparse" href="#DIVAnd.ODVspreadsheet.myparse"><code>DIVAnd.ODVspreadsheet.myparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">v = myparse(T,s)</code></pre><p>Parse the string <code>s</code> as a type <code>T</code>. Unlike Julia&#39;s parse function an error message contains the string <code>s</code> (which could not be parsed) for debugging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L400-L406">source</a></section></article><h3 id="Parameter-optimization"><a class="docs-heading-anchor" href="#Parameter-optimization">Parameter optimization</a><a id="Parameter-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-optimization" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_cv" href="#DIVAnd.DIVAnd_cv"><code>DIVAnd.DIVAnd_cv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bestfactorl,bestfactore, cvval,cvvalues, x2Ddata,y2Ddata,cvinter,xi2D,yi2D = DIVAnd_cv(mask,pmn,xi,x,f,len,epsilon2,nl,ne,method;...);</code></pre><p>Performs a cross validation to estimate the analysis parameters (correlation length and signal-to-noise ratio).</p><p><strong>Input</strong></p><p>Same as for <code>DIVAndrun</code> with three more parameters <code>nl</code>,<code>ne</code> and <code>method</code></p><ul><li><code>mask</code>: binary mask delimiting the domain. true is inside and false outside.</li></ul><p>For oceanographic application, this is the land-sea mask.</p><ul><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (m-by-1 array).   (see note)</p></li><li><p><code>len</code>: correlation length</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li><li><p><code>nl</code>: number of testing points around the current value of L. <code>1</code> means one additional point on both sides of the current L. <code>0</code> is allowed and means the parameter is not optimised.</p></li><li><p><code>ne</code>: number of testing points around the current value of epsilon2. <code>0</code> is allowed as for <code>nl</code></p></li><li><p><code>method</code>: cross validation estimator method 1: full CV 2: sampled CV 3: GCV 0: automatic choice between the three possible ones, default value</p></li><li><p>Optional input arguments specified via keyword arguments are the same as for <code>DIVAnd</code></p></li></ul><p><strong>Output:</strong></p><ul><li><p><code>bestfactorl</code>: best estimate of the multiplication factor to apply to len</p></li><li><p><code>bestfactore</code>: best estimate of the multiplication factor to apply to epsilon2</p></li><li><p><code>cvvales</code> : the cross validation values calculated</p></li><li><p><code>factors</code> : the tested multiplication factors</p></li><li><p><code>cvinter</code> : interpolated cv values for final optimisation</p></li><li><p><code>X2Data, Y2Data</code> : coordinates of sampled cross validation in <code>L,epsilon2</code> space . Normally only used for debugging or plotting</p></li><li><p><code>Xi2D, Yi2D</code> : coordinates of interpolated estimator . Normally only used for debugging or plotting</p></li></ul><p>The output <code>bestfactorl</code> and <code>bestfactore</code> represent multiplication factors which should be applied to <code>L</code> and <code>epsilon2</code>.</p><p>The <code>len</code> and <code>epsilon2</code> provided should be close the real one as the tests will be performed around.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_cv.jl#L6-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.empiriccovar" href="#DIVAnd.empiriccovar"><code>DIVAnd.empiriccovar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distx,covar,corr,varx,count = empiriccovar(x,v,distbin,mincount;
                          maxpoints = 10000,
                          distfun = (xi,xj) -&gt; sqrt(sum(abs2,xi-xj)))</code></pre><p>Compute the covariance, correlation and variance of a cloud of data points with the value <code>v</code> (a vector) and the location <code>x</code> (a tuple of vectors) grouped by distance. Random pairs are choosen and grouped by their distance (computed by <code>distfun</code>) in bins defined by <code>distbin</code>. The function try to fill at least <code>mincount</code> of data points in each bin but always stop after considering <code>maxpoints</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/fit.jl#L63-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.fithorzlen" href="#DIVAnd.fithorzlen"><code>DIVAnd.fithorzlen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lenxy,dbinfo = DIVAnd.fithorzlen(x,value,z)</code></pre><p>Determines the horizontal correlation length <code>lenxy</code> based on the measurments <code>value</code> at the location <code>x</code> (tuple of 3 vectors corresponding to longitude, latitude and depth) at the depth levels defined in <code>z</code>.</p><p>Optional arguments:</p><ul><li><code>smoothz</code> (default 100): spatial filter for the correlation scale</li><li><code>searchz</code> (default 50): vertical search distance (can also be a function of the depth)</li><li><code>maxnsamp</code> (default 5000): maximum number of samples</li><li><code>limitlen</code> (default false): limit correlation length by mean distance between  observations</li><li><code>limitfun</code> (default no function): a function with with the two arguments (depth and</li></ul><p>estimated correlation length) which returns an adjusted correlation length. For example to force the correlation length to be between 300 km and 50 km one would use the following: <code>limitfun = (z,len) -&gt; max(min(len,300_000),10_000))</code>. If provided <code>limitfun</code> is used before and after the smoothing.</p><ul><li><code>epsilon2</code> (default is a vector of the same size as <code>value</code> with all elements  equal to 1): the relative error variance of the observations. Less reliable  observation would have a larger corresponding value.</li><li><code>distfun</code>: function computing the distance between the points <code>xi</code> and <code>xj</code>.</li></ul><p>Per default it represent the Euclidian distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/fit.jl#L989-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.fitvertlen" href="#DIVAnd.fitvertlen"><code>DIVAnd.fitvertlen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lenz,dbinfo = DIVAnd.fitvertlen(x,value,z,...)</code></pre><p>See also DIVAnd.fithorzlen</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/fit.jl#L1108-L1112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.lengraddepth" href="#DIVAnd.lengraddepth"><code>DIVAnd.lengraddepth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RL = lengraddepth(pmn,h, L;
                  h2 = h,
                  hmin = 0.001
                  )</code></pre><p>Create the relative correlation length-scale field <code>RL</code> based on the bathymetry <code>h</code> and the metric <code>pmn</code> (tuple of arrays). Effectively the correlation-length scale is close to zero if the relative bathymetry gradients (|∇h|/h) are smaller  than the length-scale <code>L</code> (in consistent units as <code>pmn</code>).</p><p>R_L = 1 / (1 + L |∇h| / max(h2,hmin))</p><p>Per default <code>h2</code> is equal to <code>h</code>. The depth <code>h</code> must be positive. <code>hmin</code> must have the same units as h (usually meters).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L456-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_cvestimator" href="#DIVAnd.DIVAnd_cvestimator"><code>DIVAnd.DIVAnd_cvestimator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">theta = DIVAnd_cvestimator(s,residual)</code></pre><p>Computes the cross validation estimator <span>$(d-\hat{d})^T \mathbf R^{-1} (d-\hat{d}) / ( \mathbf 1^T \mathbf R^{-1} \mathbf 1)$</span> where the <span>$\hat{d}$</span> is the analysis not using a data point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_cvestimator.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.weight_RtimesOne" href="#DIVAnd.weight_RtimesOne"><code>DIVAnd.weight_RtimesOne</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> weights = weight_RtimesOne(x,len)</code></pre><p>Compute the weight of the observations at location <code>x</code> to reduce the influence of locally clustered data. <code>x</code> is a tuple with n elements: every element represents a coordinate of the observations. <code>len</code> is a tuple of arrays representing the correlation length. <code>len[i]</code> is the correlation length in the i-th dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_weights.jl#L138-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Rtimesx!" href="#DIVAnd.Rtimesx!"><code>DIVAnd.Rtimesx!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Rtimesx!(coord,LS,x,Rx)</code></pre><p>Gaussian type <code>R</code> matirx in <code>ndim</code> dimensions applied to vector <code>x</code> of length <code>ndata</code>. The Gaussian scale differs in each direction <code>k</code> : <code>LS[k]</code> Coordinates of point i are <code>coord[i,1],coord[i,2],...,coord[i,ndim]</code> To avoid an ndata² complexity a grid is set up first so as to allow only the calculation of covariances when distances are smaller than <code>3*LS</code></p><p>Adapted from DIVA3D/src/Fortran/Util/Rtimesx_weighting.f90</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_weights.jl#L32-L42">source</a></section></article><h3 id="Vocabulary"><a class="docs-heading-anchor" href="#Vocabulary">Vocabulary</a><a id="Vocabulary-1"></a><a class="docs-heading-anchor-permalink" href="#Vocabulary" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.@urn_str" href="#DIVAnd.Vocab.@urn_str"><code>DIVAnd.Vocab.@urn_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">urn&quot;SDN:x:y:z&#39;</code></pre><p>Resolve a SeaDataNet URN (Uniform Resource Name) using https://www.seadatanet.org/urnurl/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.CFVocab" href="#DIVAnd.Vocab.CFVocab"><code>DIVAnd.Vocab.CFVocab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">collection = Vocab.CFVocab()
collection = Vocab.CFVocab(url = url)</code></pre><p>Create a Dict-like object represeting the NetCDF CF Standard Name vocabulary. If the <code>url</code> is not provided then current CF Standard Name list http://cfconventions.org/Data/cf-standard-names/current/src/cf-standard-name-table.xml is used. Individual standard names are retirved by indexing which return an object of the type <code>CFEntry</code>:</p><pre><code class="language-julia">collection = Vocab.CFVocab()
entry = collection[&quot;sea_water_temperature&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L36-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{DIVAnd.Vocab.CFVocab,Any}" href="#Base.haskey-Tuple{DIVAnd.Vocab.CFVocab,Any}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bool = haskey(collection::CFVocab,stdname)</code></pre><p>Return true if <code>stdname</code> is part of the NetCDF CF Standard Name vocabulary <code>collection</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.SDNCollection" href="#DIVAnd.Vocab.SDNCollection"><code>DIVAnd.Vocab.SDNCollection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collection = SDNCollection(name)</code></pre><p>Open the SeaDataNet collection with the name <code>name</code> at the URL http://www.seadatanet.org/urnurl/collection/ The collection can be indexed with brackets using the identifier.</p><pre><code class="language-none">using DIVAnd
collection = Vocab.SDNCollection(&quot;P01&quot;)
concept = collection[&quot;PSALPR01&quot;]
@show Vocab.prefLabel(concept)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L207-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.prefLabel" href="#DIVAnd.Vocab.prefLabel"><code>DIVAnd.Vocab.prefLabel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s = Vocab.prefLabel(c::Vocab.Concept)</code></pre><p>Return the preferred label of a concept <code>c</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L150-L154">source</a></section><section><div><pre><code class="language-none">s = Vocab.prefLabel(urn::AbstractString)</code></pre><p>Return the preferred label of a concept usings it URN (Uniform Resource Name)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.altLabel" href="#DIVAnd.Vocab.altLabel"><code>DIVAnd.Vocab.altLabel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s = Vocab.altLabel(c::Vocab.Concept)</code></pre><p>Return the alternative label of a concept <code>c</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L150-L154">source</a></section><section><div><pre><code class="language-none">s = Vocab.altLabel(urn::AbstractString)</code></pre><p>Return the alternative label of a concept usings it URN (Uniform Resource Name)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.notation" href="#DIVAnd.Vocab.notation"><code>DIVAnd.Vocab.notation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s = Vocab.notation(c::Vocab.Concept)</code></pre><p>Return the identifier of a concept <code>c</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L150-L154">source</a></section><section><div><pre><code class="language-none">s = Vocab.notation(urn::AbstractString)</code></pre><p>Return the identifier of a concept usings it URN (Uniform Resource Name)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.definition" href="#DIVAnd.Vocab.definition"><code>DIVAnd.Vocab.definition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s = Vocab.definition(c::Vocab.Concept)</code></pre><p>Return the definition of a concept <code>c</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L150-L154">source</a></section><section><div><pre><code class="language-none">s = Vocab.definition(urn::AbstractString)</code></pre><p>Return the definition of a concept usings it URN (Uniform Resource Name)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.resolve" href="#DIVAnd.Vocab.resolve"><code>DIVAnd.Vocab.resolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">entry = Vocab.resolve(urn)</code></pre><p>Resolve a SeaDataNet URN (Uniform Resource Name) and returns the corresponding EDMO entry or Vocabulary concept. For example:</p><pre><code class="language-julia">concept = Vocab.resolve(&quot;SDN:P021:current:TEMP&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L101-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.find" href="#DIVAnd.Vocab.find"><code>DIVAnd.Vocab.find</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">concepts = Vocab.find(c::Concept,name,collection)</code></pre><p>Return a list of related concepts in the collection <code>collection</code>. <code>name</code> can be the string &quot;related&quot;, &quot;narrower&quot;, &quot;broader&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.description" href="#DIVAnd.Vocab.description"><code>DIVAnd.Vocab.description</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">str = description(entry::CFEntry)
str = canonical_units(entry::CFEntry)

Return the description or the canonical units of the `entry`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.canonical_units" href="#DIVAnd.Vocab.canonical_units"><code>DIVAnd.Vocab.canonical_units</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">str = description(entry::CFEntry)
str = canonical_units(entry::CFEntry)

Return the description or the canonical units of the `entry`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Vocab.splitURL" href="#DIVAnd.Vocab.splitURL"><code>DIVAnd.Vocab.splitURL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collection,tag,key = Vocab.splitURL(url)</code></pre><p>Split a concept URL into collection, tag and key. url must finishe with a slash.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L89-L94">source</a></section></article><h2 id="Internal-API-or-advanced-usage"><a class="docs-heading-anchor" href="#Internal-API-or-advanced-usage">Internal API or advanced usage</a><a id="Internal-API-or-advanced-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API-or-advanced-usage" title="Permalink"></a></h2><h3 id="State-vector"><a class="docs-heading-anchor" href="#State-vector">State vector</a><a id="State-vector-1"></a><a class="docs-heading-anchor-permalink" href="#State-vector" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.statevector" href="#DIVAnd.statevector"><code>DIVAnd.statevector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">sv = statevector_init((mask1, mask2, ...))</code></pre><p>Initialize structure for packing and unpacking multiple variables given their corresponding land-sea mask.</p><p>Input:   mask1, mask2,...: land-sea mask for variable 1,2,... Sea grid points correspond to one and land grid points to zero.     Every mask can have a different shape.</p><p>Output:   sv: structure to be used with statevector<em>pack and statevector</em>unpack.</p><p>Note: see also statevector<em>pack, statevector</em>unpack</p><p>Author: Alexander Barth, 2009,2017 &lt;a.barth@ulg.ac.be&gt; License: GPL 2 or later</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/statevector.jl#L24-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.pack" href="#DIVAnd.pack"><code>DIVAnd.pack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = pack(sv,(var1, var2, ...))</code></pre><p>Pack the different variables var1, var2, ... into the vector x where <code>sv</code> is a <code>statevector</code> under the control of a mask. Only sea grid points are retained.</p><p>Input:   sv: structure generated by statevector_init.   var1, var2,...: variables to pack (with the same shape as the corresponding masks).</p><p>Output:   x: vector of the packed elements. The size of this vector is the number of elements of all masks equal to 1.</p><p>Notes: If var1, var2, ... have an additional trailing dimension, then this dimension is assumed to represent the different ensemble members. In this case x is a matrix and its last dimension is the number of ensemble members.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/statevector.jl#L74-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.unpack" href="#DIVAnd.unpack"><code>DIVAnd.unpack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">var1, var2, ... = unpack(sv,x)
var1, var2, ... = unpack(sv,x,fillvalue)</code></pre><p>Unpack the vector x into the different variables var1, var2, ... where <code>sv</code> is a <code>statevector</code>.</p><p>Input:   sv: structure generated by statevector_init.   x: vector of the packed elements. The size of this vector is the number of elements equal to 1     in all masks.</p><p>Optional input parameter:   fillvalue: The value to fill in var1, var2,... where the masks correspond to a land grid point. The default is zero.</p><p>Output:   var1, var2,...: unpacked variables.</p><p>Notes: If x is a matrix, then the second dimension is assumed to represent the different ensemble members. In this case, var1, var2, ... have also an additional trailing dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/statevector.jl#L132-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.sub2ind" href="#DIVAnd.sub2ind"><code>DIVAnd.sub2ind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ind = statevector_sub2ind(sv,subscripts)</code></pre><p>Compute from a tuple of subscripts the linear index in the packed state vector. The first element of the subscript indicates the variable index and the remaining the spatial subscripts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/statevector.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ind2sub" href="#DIVAnd.ind2sub"><code>DIVAnd.ind2sub</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subscripts = ind2sub(sv,index)</code></pre><p>Compute from linear index in the packed state vector a tuple of subscripts. The first element of the subscript indicates the variable index and the remaining the spatial subscripts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/statevector.jl#L192-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><p>number of points per node it is always zero for non-leaf nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L135-L138">source</a></section></article><h3 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_constr_fluxes" href="#DIVAnd.DIVAnd_constr_fluxes"><code>DIVAnd.DIVAnd_constr_fluxes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">c = DIVAnd_constr_fluxes(s,topographyforfluxes,fluxes,epsfluxes,pmnin)</code></pre><p>Creates integral constraints for each latitude so that a barotropic correction step leads to an additional flux prescribed.</p><p>Input:   s: structure   topographyforfluxes: tuple of two 2D arrays with the bottom topography used for the flux calculations               DO NOT USE NaN in it. If an array is replaced by a scalar zero, the constraint is not used.               for fluxes calculated with geostrophy apply g/f to h   fluxes: tuple of two arrays of fluxes. The barotropic correction on elevation should be such that                         Sum over longitude at each latidute of Sum h δ(eta)/δx   δx = - fluxes[1]                         Sum over latitude  at each longitude of Sum h δ(eta)/δy  δ y = -fluxes[2]             WARNING: This has been coded to directly use geostrophy.jl output and flux directions   epsfluxes: error variance on constraint. Scaling to be verified   pmnin: metrics from the calling routine</p><p>Output:   c: structure to be used by DIVAnd_addc with the following fields: R (a     covariance matrix), H (extraction operator) and yo (specified value for     the constrain).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_constr_fluxes.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_constr_constcoast" href="#DIVAnd.DIVAnd_constr_constcoast"><code>DIVAnd.DIVAnd_constr_constcoast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">c = DIVAnd_constr_constcoast(mask,eps2)</code></pre><p>Constrain imposing that the gradients along the coastline defined by <code>mask</code> are close to zero controlled by the parameter <code>eps2</code> which represents the scaled error variance on the gradients.</p><p>This constrain is useful to indirectly impose that a stream function does not have a current component perpendicular to the coastline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_constr_constcoast.jl#L103-L112">source</a></section></article><h3 id="ODV-files"><a class="docs-heading-anchor" href="#ODV-files">ODV files</a><a id="ODV-files-1"></a><a class="docs-heading-anchor-permalink" href="#ODV-files" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.listSDNparams" href="#DIVAnd.ODVspreadsheet.listSDNparams"><code>DIVAnd.ODVspreadsheet.listSDNparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">p = listSDNparam(ODVData)</code></pre><p>Return a list of SeaDataNet P01 parameters in a ODV spreadsheet <code>ODVData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.load" href="#DIVAnd.ODVspreadsheet.load"><code>DIVAnd.ODVspreadsheet.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> obsvalue,obslon,obslat,obsdepth,obstime,obsids = load(T,fnames,datanames;
    qv_flags = [DIVAnd.ODVspreadsheet.GOOD_VALUE,
                DIVAnd.ODVspreadsheet.PROBABLY_GOOD_VALUE],
    nametype = :P01,
    qvlocalname = &quot;QV:SEADATANET&quot;)</code></pre><p>Load all the profiles from every files listed in the array <code>fnames</code> corresponding to one of the parameter names <code>datanames</code>. If <code>nametype</code> is <code>:P01</code> (default), the datanames are P01 vocabulary names with the SDN prefix. If nametype is <code>:localname</code>, then they are the ODV column header without units.</p><p>For example if the column header is <code>Water body salinity [per mille]</code>, then <code>datenames</code> should be <code>[&quot;Water body salinity&quot;]</code>. The resulting vectors have the data type <code>T</code> (expect <code>times</code> and <code>ids</code> which are vectors of <code>DateTime</code> and <code>String</code> respectively). Only values matching the quality flag <code>qv_flags</code> are retained. <code>qv_flags</code> is a vector of Strings (based on http://vocab.nerc.ac.uk/collection/L20/current/, e.g. &quot;1&quot; means &quot;good value&quot;). One can also use the constants these constants (prefixed with <code>DIVAnd.ODVspreadsheet.</code>):</p><p><code>qvlocalname</code> is the column name to denote quality flags. It is assumed that the quality flags follow immediately the data column.</p><table><tr><th style="text-align: right">constant</th><th style="text-align: right">value</th></tr><tr><td style="text-align: right"><code>NO_QUALITY_CONTROL</code></td><td style="text-align: right">&quot;0&quot;</td></tr><tr><td style="text-align: right"><code>GOOD_VALUE</code></td><td style="text-align: right">&quot;1&quot;</td></tr><tr><td style="text-align: right"><code>PROBABLY_GOOD_VALUE</code></td><td style="text-align: right">&quot;2&quot;</td></tr><tr><td style="text-align: right"><code>PROBABLY_BAD_VALUE</code></td><td style="text-align: right">&quot;3&quot;</td></tr><tr><td style="text-align: right"><code>BAD_VALUE</code></td><td style="text-align: right">&quot;4&quot;</td></tr><tr><td style="text-align: right"><code>CHANGED_VALUE</code></td><td style="text-align: right">&quot;5&quot;</td></tr><tr><td style="text-align: right"><code>VALUE_BELOW_DETECTION</code></td><td style="text-align: right">&quot;6&quot;</td></tr><tr><td style="text-align: right"><code>VALUE_IN_EXCESS</code></td><td style="text-align: right">&quot;7&quot;</td></tr><tr><td style="text-align: right"><code>INTERPOLATED_VALUE</code></td><td style="text-align: right">&quot;8&quot;</td></tr><tr><td style="text-align: right"><code>MISSING_VALUE</code></td><td style="text-align: right">&quot;9&quot;</td></tr><tr><td style="text-align: right"><code>VALUE_PHENOMENON_UNCERTAIN</code></td><td style="text-align: right">&quot;A&quot;</td></tr></table><p>If the ODV does not contain a semantic header (e.g. for the aggregated ODV files), then local names must be used.</p><pre><code class="language-julia-repl">julia&gt; data,obslon,obslat,obsdepth,obstime,obsids = DIVAnd.ODVspreadsheet.load(Float64,[&quot;data_from_med_profiles_non-restricted_v2.txt&quot;],
      [&quot;Water body salinity&quot;]; nametype = :localname );</code></pre><p>In order to read ODV spreasheet containing World Ocean Database file <code>odvfile</code>, one can use a command like:</p><pre><code class="language-julia-repl">julia&gt; obsval,obslon,obslat,obsdepth,obstime,obsid = ODVspreadsheet.load(Float64,[odvfile],
                           [&quot;Temperature&quot;]; qv_flags=[&quot;0&quot;, &quot;1&quot;], nametype = :localname, qvlocalname = &quot;QV:WOD&quot;);</code></pre><p>i.e.,</p><ul><li>explicitely specifying the accepted flags <code>qv_flags</code></li><li>set <code>qvlocalname</code> as &quot;QV:WOD&quot;.</li></ul><p><em>Note:</em> no checks are performed to ensure the units are consistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L666-L725">source</a></section><section><div><pre><code class="language-none"> profiles,lons,lats,depths,times,ids = load(T,dir,P01names)</code></pre><p>Load all the ODV files under the directory <code>dir</code> corresponding the one of the parameter names <code>P01names</code>. The resulting vectors have the data type <code>T</code> (expect <code>times</code> and <code>ids</code> which are vectors of <code>DateTime</code> and <code>String</code>, respectively).</p><p>No checks are done to ensure the units are consistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L817-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.localnames" href="#DIVAnd.ODVspreadsheet.localnames"><code>DIVAnd.ODVspreadsheet.localnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">list = localnames(sheet,P01name)</code></pre><p>Return a list <code>list</code> of all local names mapping to the specified <code>P01name</code> in the ODV spreadsheet <code>sheet</code> without the prefix &quot;SDN:LOCAL:&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L312-L318">source</a></section><section><div><pre><code class="language-none">list = localnames(sheet)</code></pre><p>Return a list <code>list</code> of all local names  in the ODV spreadsheet <code>sheet</code> without the prefix &quot;SDN:LOCAL:&quot; in the order as they appear in the ODV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L324-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.Spreadsheet" href="#DIVAnd.ODVspreadsheet.Spreadsheet"><code>DIVAnd.ODVspreadsheet.Spreadsheet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Define composite type that will contain:</p><ul><li>the metadata (dictionary),</li><li>SDN parameter mapping (dictionary)</li><li>the column labels (array) and</li><li>the profiles (array of arrays).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.loadprofile" href="#DIVAnd.ODVspreadsheet.loadprofile"><code>DIVAnd.ODVspreadsheet.loadprofile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> data,data_qv,obslon,obslat,obsdepth,obsdepth_qv,obstime,obstime_qv,EDMO,LOCAL_CDI_ID =
 loadprofile(T,sheet,iprofile,dataname; nametype = :P01)</code></pre><p>Load a <code>iprofile</code>-th profile from the ODV spreadsheet <code>sheet</code> of the parameter <code>dataname</code>. If <code>nametype</code> is <code>:P01</code> (default), the dataname is the P01 vocabulary name with the SDN prefix. If nametype is <code>:localname</code>, then it is the ODV column header.  The resulting vectors have the data type <code>T</code> (expect the quality flag and <code>obstime</code>) .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L524-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.loaddataqv" href="#DIVAnd.ODVspreadsheet.loaddataqv"><code>DIVAnd.ODVspreadsheet.loaddataqv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">data,data_qv = loaddataqv(sheet,profile,locname,fillvalue; fillmode = :repeat)</code></pre><p>The same as <code>loaddata</code>, but now the quality flag are also loaded.</p><p>profile[i][j] is the j-th column of the i-th row of a profile. profile[i,j] is the i-th column of the j-th row of a profile.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L478-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.SDNparse!" href="#DIVAnd.ODVspreadsheet.SDNparse!"><code>DIVAnd.ODVspreadsheet.SDNparse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SDNparse!(col,fillmode,fillvalue,data)</code></pre><p>Parse the list of String <code>col</code> into the corresponding data type of the vector <code>data</code>. Empty values are either replaced by <code>fillvalue</code> (if fillmode is :fill) or the previous value if repeated (if fillmode is :repeat)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L420-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.colnumber" href="#DIVAnd.ODVspreadsheet.colnumber"><code>DIVAnd.ODVspreadsheet.colnumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cn = colnumber(sheet,localname)</code></pre><p>Return the column number <code>cn</code> of the first column with the local name <code>localname</code> (without the prefix &quot;SDN:LOCAL:&quot;) in the ODV spreadsheet <code>sheet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ODVspreadsheet.nprofiles" href="#DIVAnd.ODVspreadsheet.nprofiles"><code>DIVAnd.ODVspreadsheet.nprofiles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">n = nprofiles(ODVData)</code></pre><p>Return the number of profiles in a ODV Spreadsheet <code>ODVData</code> loaded by <code>readODVspreadsheet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/ODVspreadsheet.jl#L43-L48">source</a></section></article><h3 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.sparse_interp" href="#DIVAnd.sparse_interp"><code>DIVAnd.sparse_interp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">H,out = sparse_interp(mask,I)</code></pre><p>Create interpolation matrix from <code>mask</code> and fractional indexes <code>I</code>.</p><p>Input:   mask: 0 invalid and 1 valid points (n-dimensional array)   I: fractional indexes (2-dim array n by mi, where mi is the number of points to interpolate) Ouput:   H: sparse matrix with interpolation coefficients   out: true if value outside of grid   outbbox: 1 if outise bouding box   onland: 1 if point touches land (where mask == 0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/sparse_interp.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.sparse_interp_g" href="#DIVAnd.sparse_interp_g"><code>DIVAnd.sparse_interp_g</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sparse_interp(x,mask,xi) Interpolate from x onto xi</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/sparse_interp.jl#L145-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.sparse_diff" href="#DIVAnd.sparse_diff"><code>DIVAnd.sparse_diff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diffx = sparse_diff(sz1,m,cyclic)</code></pre><p>Sparse operator for differentiation along dimension <code>m</code> for &quot;collapsed&quot; matrix of the size <code>sz1</code>. <code>cyclic</code> is true if domain is cyclic along dimension m. <code>false</code> is the default value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/sparse_diff.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.matfun_trim" href="#DIVAnd.matfun_trim"><code>DIVAnd.matfun_trim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T = matfun_trim(sz1,m)</code></pre><p>Create an operator which trim first and last row (or column) in The field is a &quot;collapsed&quot; matrix of the size <code>sz1</code>. <code>m</code> is the dimension to trim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/function_operator.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.matfun_stagger" href="#DIVAnd.matfun_stagger"><code>DIVAnd.matfun_stagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">S = matfun_stagger(sz1,m,cyclic)</code></pre><p>Create an operator for staggering a field in dimension m. The field is a &quot;collapsed&quot; matrix of the size sz1.</p><p>Input:   sz1: size of rhs   m: dimension to stagger   cyclic: true if domain is cyclic along dimension m. False is the   default value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/function_operator.jl#L141-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.matfun_diff" href="#DIVAnd.matfun_diff"><code>DIVAnd.matfun_diff</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Operator for differentiation.</p><pre><code class="language-none">diffx = matfun_diff(sz1,m,cyclic)</code></pre><p>Operator for differentiation along dimension m for &quot;collapsed&quot; matrix of the size sz1.</p><p>Input:   sz1: size of rhs   m: dimension to differentiate   cyclic: true if domain is cyclic along dimension m. False is the   default value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/function_operator.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.matfun_shift" href="#DIVAnd.matfun_shift"><code>DIVAnd.matfun_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Operator shifting a field in a given dimension.</p><pre><code class="language-none">function S = matfun_shift(sz1,m,cyclic)</code></pre><p>Operator shifting a field in the dimension m. The field is a &quot;collapsed&quot; matrix of the size sz1.</p><p>Input:   sz1: size of rhs   m: dimension to shift   cyclic: true if domain is cyclic along dimension m. False is the     default value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/function_operator.jl#L94-L107">source</a></section></article><h3 id="Quadtree"><a class="docs-heading-anchor" href="#Quadtree">Quadtree</a><a id="Quadtree-1"></a><a class="docs-heading-anchor-permalink" href="#Quadtree" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.QT" href="#DIVAnd.Quadtrees.QT"><code>DIVAnd.Quadtrees.QT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>quadtree (of the higher-dimensional equivalent) T the type of the coordinates TA the type of the attributes N number of dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.rsplit!" href="#DIVAnd.Quadtrees.rsplit!"><code>DIVAnd.Quadtrees.rsplit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>recursive split</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L288-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.add!" href="#DIVAnd.Quadtrees.add!"><code>DIVAnd.Quadtrees.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sucess = add!(qt,x,attrib,max_cap = 10) Add point <code>x</code> with the attribute <code>attrib</code> to the quadtree <code>qt</code>. <code>sucess</code> is true if <code>x</code> is within the bounds of the quadtree node <code>qt</code> (otherwise false and the point has not been added)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.within" href="#DIVAnd.Quadtrees.within"><code>DIVAnd.Quadtrees.within</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">attribs = within(qt,min,max)</code></pre><p>Search all the points within a bounding box defined by the vectors <code>min</code> and <code>max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L338-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.bitget" href="#DIVAnd.Quadtrees.bitget"><code>DIVAnd.Quadtrees.bitget</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Test if the n-th bit in a is set. The least significant bit is n = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.inside" href="#DIVAnd.Quadtrees.inside"><code>DIVAnd.Quadtrees.inside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inside(x0,x1,y)</code></pre><p>Returns true of the point <code>y</code> is inside the rectange defined by <code>x0</code> and <code>x1</code>.</p><pre><code class="language-none">             x1
  +----------+
  |          |
  |   +      |
  |   y      |
  +----------+
 x0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L51-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.intersect" href="#DIVAnd.Quadtrees.intersect"><code>DIVAnd.Quadtrees.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Test if the rectanges defined by x0,x1 and y0,y1 intersects/overlap</p><pre><code class="language-none">             x1
  +----------+
  |          |
  |   +----------+ y1
  |   |      |   |
  +----------+   |
 x0   |          |
      |          |
      +----------+
     y0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L81-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.Quadtrees.split!" href="#DIVAnd.Quadtrees.split!"><code>DIVAnd.Quadtrees.split!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>split a single node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Quadtrees.jl#L230-L232">source</a></section></article><h3 id="Conjugate-gradient"><a class="docs-heading-anchor" href="#Conjugate-gradient">Conjugate gradient</a><a id="Conjugate-gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Conjugate-gradient" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.conjugategradient" href="#DIVAnd.conjugategradient"><code>DIVAnd.conjugategradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x,cgsuccess,niter = conjugategradient(fun!,b)</code></pre><p>Solve a linear system with the preconditioned conjugated-gradient method: A x = b where <code>A</code> is a symmetric positive defined matrix and <code>b</code> is a vector. Equivalently the solution <code>x</code> minimizes the cost function J(x) = ½ xᵀ A x - bᵀ x.</p><p>The function <code>fun!(x,fx)</code> computes fx which is equal to  <code>A*x</code>. For example:</p><pre><code class="language-none">function fun!(x,fx)
    fx[:] = A*x
end</code></pre><p>Note that the following code will NOT work, because a new array <code>fx</code> would be created and it would not be passed back to the caller.</p><pre><code class="language-none">function fun!(x,fx)
    fx = A*x # bug!
end</code></pre><p>The function <code>fun!</code> works in-place to reduce the amount of memory allocations.</p><p><strong>Optional input arguments</strong></p><ul><li><code>x0</code>: starting vector for the interations</li><li><code>tol</code>: tolerance on  |Ax-b| / |b|</li><li><code>maxit</code>: maximum of interations</li><li><code>pc!</code>: the preconditioner. The functions <code>pc(x,fx)</code> computes fx = M⁻¹ x (the inverse of M times x) where <code>M</code> is a symmetric positive defined matrix. Effectively, the system E⁻¹ A (E⁻¹)ᵀ (E x) = E⁻¹ b is solved for (E x) where E Eᵀ = M. Ideally, M should this be similar to A, so that E⁻¹ A (E⁻¹)ᵀ is close to the identity matrix. The function <code>pc!</code> should be implemented in a similar way than <code>fun!</code> (see above).</li></ul><p><strong>Output</strong></p><ul><li><code>x</code>: the solution</li><li><code>cgsuccess</code>: true if the interation converged (otherwise false)</li><li><code>niter</code>: the number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/conjugategradient.jl#L55-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.pc_none!" href="#DIVAnd.pc_none!"><code>DIVAnd.pc_none!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pc_none!(x,fx)</code></pre><p>Dummy call-back function when no preconditioner is used. <code>fx</code> will be equal to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/conjugategradient.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.checksym" href="#DIVAnd.checksym"><code>DIVAnd.checksym</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xAy, yATx = checksym(n,fun!)</code></pre><p>Check if the the function <code>fun!</code> represents a symmetric matrix when applied on random vectors of size <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/conjugategradient.jl#L11-L16">source</a></section></article><h3 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_laplacian" href="#DIVAnd.DIVAnd_laplacian"><code>DIVAnd.DIVAnd_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create the laplacian operator.</p><pre><code class="language-none">Lap = DIVAnd_laplacian(mask,pmn,nu,iscyclic)</code></pre><p>Form a Laplacian using finite differences assumes that gradient is zero at &quot;coastline&quot;</p><p>Input: mask: binary mask delimiting the domain. 1 is inside and 0 outside. For oceanographic application, this is the land-sea mask. pmn: scale factor of the grid. nu: diffusion coefficient of the Laplacian field of the size mask or cell arrays of fields</p><p>Output: Lap: sparce matrix represeting a Laplacian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_laplacian.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_gradient" href="#DIVAnd.DIVAnd_gradient"><code>DIVAnd.DIVAnd_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Dx1,Dx2,...,Dxn = DIVAnd.DIVAnd_gradient(operatortype,mask,pmn,iscyclic)</code></pre><p>Form the gradient using finite differences in all n-dimensions. <code>mask</code> is a binary mask delimiting the domain. 1 is inside and 0 outside. For oceanographic application, this is the land-sea mask. <code>pmn</code> is a tuple of arrays with the scale factor of the grid. The output <code>Dx1,Dx2,...,Dxn</code> are sparse matrices represeting a gradient along different dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/sparse_gradient.jl#L5-L14">source</a></section><section><div><pre><code class="language-none">Dx1,Dx2,...,Dxn = DIVAnd.DIVAnd_gradient(operatortype,mask,pmn,iscyclic)</code></pre><p>Form the gradient using finite differences in all n-dimensions. <code>mask</code> is a binary mask delimiting the domain. 1 is inside and 0 outside. For oceanographic application, this is the land-sea mask. <code>pmn</code> is a tuple of arrays with the scale factor of the grid. The output <code>Dx1,Dx2,...,Dxn</code> are sparse matrices represeting a gradient along different dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/sparse_gradient.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_obscovar" href="#DIVAnd.DIVAnd_obscovar"><code>DIVAnd.DIVAnd_obscovar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">R = DIVAnd_obscovar(epsilon2,m)</code></pre><p>Create a matrix representing the observation error covariance R of size m x m.</p><p>If epsilon2 is a scalar, then R = epsilon2 * I If epsilon2 is a vector, then R = diag(epsilon2) If epsilon2 is a matrix, then R = epsilon2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_obscovar.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_adaptedeps2" href="#DIVAnd.DIVAnd_adaptedeps2"><code>DIVAnd.DIVAnd_adaptedeps2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">factor = DIVAnd_adaptedeps2(s,fi);</code></pre><p><strong>Input:</strong></p><ul><li><code>s</code>: structure returned by <code>DIVAndrun</code></li><li><code>fi</code>: analysis returned by <code>DIVAndrun</code></li></ul><p><strong>Output:</strong></p><ul><li><code>factor</code> : multiplicative factor to apply to epsilon2</li></ul><p>Using Deroziers adaptive approach provides a multiplicative factor for the current epsilon2 value so that factor*epsilon2 is a better estimate of the R matrix. If you cannot use <code>DIVAndrun</code> but use <code>DIVAndgo</code>, the latter provides automatically this pamater as result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_adaptedeps2.jl#L1-L17">source</a></section><section><div><pre><code class="language-none">DIVAnd_adaptedeps2(yo, residual, diagR, ignoreobs)</code></pre><p>Using Deroziers adaptive approach provides a multiplicative factor for the current epsilon2 value so that factor*epsilon2 is a better estimate of the R matrix.</p><p><code>yo</code> the observations (minus the background), <code>residual</code> the obserations minus the analysis, <code>diagR</code>, the diagonal of the rel. obs. error covariance matrix and <code>ignoreobs</code> is true if an observation is out of the grid or should be ignored for other reasons.</p><p>For unscaled R and assuming that the background is zero, Deroziers showed that:</p><p>mean((yᵒ - Hxᵃ) ⋅ yᵒ) =  ϵ² mean(yᵒ ⋅ yᵒ) = σ² +  ϵ²</p><p>mean(yᵒ ⋅ yᵒ) / mean((yᵒ - Hxᵃ) ⋅ yᵒ) = σ²/ϵ² + 1 λ = σ²/ϵ² = 1 - mean(yᵒ ⋅ yᵒ) / mean((yᵒ - Hxᵃ) ⋅ yᵒ)</p><p>ϵ² / σ² = 1 / λ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_adaptedeps2.jl#L27-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_diagHKobs" href="#DIVAnd.DIVAnd_diagHKobs"><code>DIVAnd.DIVAnd_diagHKobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diagonalterms = DIVAnd_diagHKobs(s)</code></pre><p>Computes the diagonal terms of the so called hat-matrix HK, using the already solved analysis and it structure s. Warning: might take some time</p><p>This version only uses the real data (not those related to additional constraints)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_diagHKobs.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_residual" href="#DIVAnd.DIVAnd_residual"><code>DIVAnd.DIVAnd_residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dataresidual = DIVAnd_residual(s,fi)</code></pre><p>Computes the generalized residual yo - H xa  using the analysis on the grid <code>fi</code> and the solution structure <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_residual.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_addc" href="#DIVAnd.DIVAnd_addc"><code>DIVAnd.DIVAnd_addc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s = DIVAnd_addc(s,c)</code></pre><p>Add a constraint <code>c</code> to the cost function defined by <code>s</code>. The structure <code>s</code> is typically created by DIVAnd_background and the contrain <code>c</code> has the following fields: <code>R</code> (a covariance matrix), <code>H</code> (extraction operator) and <code>yo</code> (specified value for the constrain). The added contrain Jc(x) is quadratic and has the following structure.</p><p>Jc(x) = (H x - yo)ᵀ R⁻¹ (H x - yo)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_addc.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_erroratdatapoints" href="#DIVAnd.DIVAnd_erroratdatapoints"><code>DIVAnd.DIVAnd_erroratdatapoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">errorvariance = DIVAnd_erroratdatapoints(s;restrictedlist=[])</code></pre><p>Computes the error at the real data locations using the analysis structure s</p><p>If a restricedlist is provided erros are only calculated at the indexes where restricedlist==true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_erroratdatapoints.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_GCVKii" href="#DIVAnd.DIVAnd_GCVKii"><code>DIVAnd.DIVAnd_GCVKii</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes an estimate of the mean value of the diagonal of HK using GCV and the already solved analysisand it structure s</p><p>Kii = DIVAnd_GCVKii(s);</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_GCVKii.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_fittocpu" href="#DIVAnd.DIVAnd_fittocpu"><code>DIVAnd.DIVAnd_fittocpu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> stepsize,overlapping,isdirect = DIVAnd_fittocpu(Lpmnrange,gridsize,latercsteps,moddim,MEMTOFIT;forcedirect=false,overlapfactor=3.3);</code></pre><p><strong>Creates a list of windows for subsequent domain decomposition</strong></p><p><strong>Also calculates already the subsampling steps <code>csteps</code> for the preconditionners</strong></p><p><strong>Input:</strong></p><ul><li><code>Lpmnrange</code>: for every dimension the minimum and maximum correlation length scaled by the local resolution (i.e. the product between L and pm (pn,...))</li><li><code>gridsize</code>: number of points in each direction (size(mask))</li><li><code>latercsteps</code>: coarsening steps used later if a lower resolution model is used for preconditioning.</li><li><code>moddim</code>: modulo for cyclic dimension (vector with n elements). Zero is used for non-cyclic dimensions.</li><li><code>memtofit</code> : parameter describing how much memory is expected to be available in Gb</li><li><code>forcedirect</code> : if true forces direct solver even if iterative solver might allow for larger tiles</li><li><code>overlapfactor</code> : describes how many times the length scale is used for the overlapping. default is 3.3. use lower values ONLY for very good data coverage.</li></ul><p><strong>Output:</strong></p><ul><li><code>stepsize</code>: spatial (and temporal) shift in grid points between subdomains for every dimension (?)</li><li><code>overlapping</code>: number of overlapping grid points for every dimension</li><li><code>isdirect</code>: true is the direct solver is activated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_fittocpu.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_background" href="#DIVAnd.DIVAnd_background"><code>DIVAnd.DIVAnd_background</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Form the inverse of the background error covariance matrix. s = DIVAnd_background(mask,pmn,Labs,alpha,moddim) Form the inverse of the background error covariance matrix with finite-difference operators on a curvilinear grid</p><p><strong>Input:</strong></p><ul><li>mask: binary mask delimiting the domain. 1 is inside and 0 outside.       For oceanographic applications, this is the land-sea mask.</li><li>pmn: scale factor of the grid.</li><li>Labs: correlation length</li><li>alpha: dimensional coefficients for norm, gradient, laplacian,...    alpha is usually [1,2,1] in 2 dimensions.</li></ul><p><strong>Output:</strong></p><ul><li>s: structure containing<ul><li>s.iB: inverse of the background error covariance</li><li>s.L: spatially averaged correlation length</li><li>s.n: number of dimensions</li><li>s.coeff: scaling coefficient such that the background variance diag(inv(iB)) is one far away from the boundary.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_background.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_obs" href="#DIVAnd.DIVAnd_obs"><code>DIVAnd.DIVAnd_obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s = DIVAnd_obs(s,xi,x,R,I)</code></pre><p>Include the constrain from the observations. It is assumed that each coordinate depends only on one index. If this is not the case, then matrix I must be provided.</p><p>Input:   s: structure created by DIVAnd_background   xi: coordinates of observations (tuple of vectors)   x: coordinates of grid (tuple of arrays)   R: obs. error covariance matrix (normalized)   I (optional): fractional indexes of location of observation     within the grid</p><p>Output:   s: structure to be used by DIVAnd_factorize</p><p>Note: make sure not to mix Float32 and Float64 for DIVAnd_constrain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_obs.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_bc_stretch" href="#DIVAnd.DIVAnd_bc_stretch"><code>DIVAnd.DIVAnd_bc_stretch</code></a> — <span class="docstring-category">Function</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_bc_stretch.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_diagHK" href="#DIVAnd.DIVAnd_diagHK"><code>DIVAnd.DIVAnd_diagHK</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes the diagonal terms of the so called hat-matrix HK, using the already solved analysis and it structure s. Warning: might take some time</p><p>diagonalterms = DIVAnd_diagHK(s);</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_diagHK.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_kernel" href="#DIVAnd.DIVAnd_kernel"><code>DIVAnd.DIVAnd_kernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mu,K,len_scale = DIVAnd_kernel(n,alpha)</code></pre><p>Return the analytical kernel and normalization factor.</p><p>Analytical (normalized) kernels <code>K</code> for infinite domain in dimension <code>n</code> and for coefficients <code>alpha</code> and normalization factor <code>mu</code>.</p><p><code>K(r)</code> is the kernel function (function of the normalized distance <code>r</code>), <code>len_scale</code> is the distance at which <code>K(len_scale)</code> = 0.6019072301972346 (which is besselk(1,1))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_kernel.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_residualobs" href="#DIVAnd.DIVAnd_residualobs"><code>DIVAnd.DIVAnd_residualobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dataresidual = DIVAnd_residualobs(s,fi);</code></pre><p>Computes the residual yo - H xa  only at real data points using the analysis. on the grid <code>fi</code> and the solution structure <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_residualobs.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_aexerr" href="#DIVAnd.DIVAnd_aexerr"><code>DIVAnd.DIVAnd_aexerr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aexerr,Bref,fa,sa = DIVAnd_aexerr(mask,pmn,xi,x,f,len,epsilon2;...);</code></pre><p><strong>Input: same as for DIVAndrun</strong></p><ul><li><p><code>mask</code>: binary mask delimiting the domain. true is inside and false outside. For oceanographic application, this is the land-sea mask.</p></li><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (m-by-1 array).   (see note)</p></li><li><p><code>len</code>: correlation length</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li></ul><p><strong>Optional input arguments specified as keyword arguments also as for DIVAnd</strong></p><p><strong>Output:</strong></p><ul><li><p><code>aexerr</code>: the almost exact error</p></li><li><p><code>Bref</code>: the background error for error scaling by background <code>aexerr./Bref</code></p></li><li><p><code>fa</code>: the analysis (with low impact fake data): DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING</p></li><li><p><code>sa</code>: the associated structure</p></li></ul><p>Compute a variational analysis of arbitrarily located observations to calculate the almost exact error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_aexerr.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_cpme" href="#DIVAnd.DIVAnd_cpme"><code>DIVAnd.DIVAnd_cpme</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cpme = DIVAnd_cpme(mask,pmn,xi,x,f,len,epsilon2;...);</code></pre><p><strong>Input: Same as for <code>DIVAndrun</code></strong></p><ul><li><code>mask</code>: binary mask delimiting the domain. true is inside and false outside.</li></ul><p>For oceanographic application, this is the land-sea mask.</p><ul><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>xi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</p></li><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations <em>minus</em> the background estimate (m-by-1 array).   (see note)</p></li><li><p><code>len</code>: correlation length</p></li><li><p><code>epsilon2</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li><li><p><code>keywords</code> : undocumented for the moment how to use iterative solver with coarser grid as preconditionner. see <code>DIVAndjog</code> for <code>csteps</code>, <code>lmask</code> and <code>alphapc</code>parameters</p></li></ul><p><strong>Optional input arguments specified as keyword arguments also as for DIVAnd</strong></p><p><strong>Output:</strong></p><ul><li><code>cpme</code>: the clever poor mans error</li></ul><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>cpme</code> represent the error field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>. If you cannot run <code>DIVAndrun</code> you can use <code>DIVAndgo</code> with error field calculation <code>:cpme</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_cpme.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_cpme_go" href="#DIVAnd.DIVAnd_cpme_go"><code>DIVAnd.DIVAnd_cpme_go</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">erri = DIVAnd_cpme_go(mask,pmn,xi,x,f,len,epsilon2; ...);</code></pre><p><strong>Input:</strong></p><ul><li>Same arguments as DIVAndrun with in addition</li><li><code>MEMTOFIT=</code>: keyword controlling how to cut the domain depending on the memory remaining available for inversion (not total memory)</li><li><code>RTIMESONESCALES=</code> : if you provide a tuple of length scales, data are weighted differently depending on the numbers of neighbours they have. See <code>weight_RtimesOne</code> for details</li></ul><p><strong>Output:</strong></p><ul><li><code>erri</code>: relative error field using the clever poor man&#39;s error approach. Result on the same grid as fi.</li></ul><p>ONLY USE THIS VERSION IF YOU CANNOT RUN <code>DIVAndgo</code> with <code>:cmpe</code> activated (or directly <code>DIVAnd_cpme</code> if you can run <code>DIVAndrun</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_cpme_go.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_datainboundingbox" href="#DIVAnd.DIVAnd_datainboundingbox"><code>DIVAnd.DIVAnd_datainboundingbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xn,fn,indexes,Rn = DIVAnd_datainboundingbox(xi,x,f;Rmatrix=())</code></pre><p><strong>Input:</strong></p><p><code>xi</code>: tuple with n elements. Every element represents a coordinate   of the final grid on which the observations are interpolated</p><ul><li><p><code>x</code>: tuple with n elements. Every element represents a coordinate of the observations</p></li><li><p><code>f</code>: value of the observations</p></li><li><p><code>Rmatrix</code>: error variance of the observations (normalized by the error variance of the background field). <code>epsilon2</code> can be a scalar (all observations have the same error variance and their errors are decorrelated), a vector (all observations can have a difference error variance and their errors are decorrelated) or a matrix (all observations can have a difference error variance and their errors can be correlated). If <code>epsilon2</code> is a scalar, it is thus the <em>inverse of the signal-to-noise ratio</em>.</p></li></ul><p><strong>Output:</strong></p><p><code>xn</code>: tuple with n elements. Every element represents a coordinate of   the observations which falls in the bounding box defined by xi <code>fn</code>: the corresponding data <code>indexes:</code> the indexes in the original array retained <code>Rn</code>: the new error variance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_datainboundingbox.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_Lpmnrange" href="#DIVAnd.DIVAnd_Lpmnrange"><code>DIVAnd.DIVAnd_Lpmnrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lpmnrange = DIVAnd_Lpmnrange(pmn,len);</code></pre><p><strong>In each direction, searches for the minimum and maximum value of the length scale times the metric in this direction</strong></p><p><strong>So it basically looks at the worst and the best resolution found in the grid</strong></p><p><strong>Input:</strong></p><ul><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>len</code>: correlation length</p></li></ul><p><strong>Output:</strong></p><ul><li><code>Lpmnrange</code>: Array of range tuples (minimum and maximum of L times metric)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_Lpmnrange.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_pc_sqrtiB" href="#DIVAnd.DIVAnd_pc_sqrtiB"><code>DIVAnd.DIVAnd_pc_sqrtiB</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute a preconditioner using the Cholesky decomposition.</p><pre><code class="language-none">[M1,M2] = DIVAnd_pc_michol(iB,H,R)</code></pre><p>Compute preconditioner matrices M1 and M2 based on the Cholesky decomposition of iB. The matrices H and R are not used. M2 is the transpose of M1 for this preconditioner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_pc_sqrtiB.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_pc_none" href="#DIVAnd.DIVAnd_pc_none"><code>DIVAnd.DIVAnd_pc_none</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fun = DIVAnd_pc_none(iB,H,R)</code></pre><p>Dummy function for requiring that no preconditioner is used in DIVAnd.</p><p>See also: diavnd<em>pc</em>sqrtiB</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_pc_none.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_GCVKiiobs" href="#DIVAnd.DIVAnd_GCVKiiobs"><code>DIVAnd.DIVAnd_GCVKiiobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Kii = DIVAnd_GCVKiiobs(s)</code></pre><p>Computes an estimate of the mean value of the diagonal of HK using GCV and the already solved analysis and it structure s Only using real data locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_GCVKiiobs.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_cutter" href="#DIVAnd.DIVAnd_cutter"><code>DIVAnd.DIVAnd_cutter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">windowlist,csteps,lmask,alphapc = DIVAnd_cutter(Lpmnrange,gridsize,moddim,MEMTOFIT);</code></pre><p>Creates a list of windows for subsequent domain decomposition. Also calculates already the subsampling steps csteps for the preconditionners as well as the mask lmask to apply to the length scales in the preconditionner, allowing to reduce the problem size</p><p><strong>Input:</strong></p><ul><li><code>Lpmnrange</code>:</li><li><code>gridsize</code>: number of points in each direction (size(mask))</li><li><code>moddim</code>:</li><li><code>MEMTOFIT</code></li><li><code>overlapfactor</code> : describes how many times the length scale is used for the overlapping. default is 3.3. use lower values ONLY for very good data coverage.</li></ul><p><strong>Output:</strong></p><ul><li><code>windowlist</code>: vector of tuples (iw1,iw2,isol1,isol2,istore1,istore2,)   where <code>(iw1,iw2)</code> correspond to the start and end indices in the (global)   grid <code>(isol1,isol2)</code> correspond to the start and end indices solution   to be retained in the window (not all is retained due to overlapping)   and <code>(istore1,istore2)</code> correspond to the start and end indices of the solution   relative to the global grid. They define thus where the local solution has to be   stored in the combined global solution.</li><li><code>csteps</code>: Array of steps for the coarse grid preconditionner. <code>csteps</code> is zero for the direct solver.</li><li><code>lmask</code>: Array of multiplication factors for length scale of preconditionner</li><li><code>alphapc</code>: Norm defining coefficients for preconditionner</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_cutter.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_qc" href="#DIVAnd.DIVAnd_qc"><code>DIVAnd.DIVAnd_qc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qcvalues = DIVAnd_qc(fi,s,method);</code></pre><p>Perform a quality control of the observations using the interpolated field.</p><p><strong>Input:</strong></p><ul><li><code>fi</code> : interpolated field from a <code>DIVAndrun</code> execution</li><li><code>s</code>: corresponding structure returned by <code>DIVAnd</code></li><li><code>method</code> : optional argument, which describes the method to be used:</li></ul><p>1  as for standard cross validation,  3  as for GCV,  4  with CV estimator to be used outside the routine,  5  Poor man&#39;s GCV using data instead of random vector,  0  automatic selection of method.</p><p><strong>Output</strong></p><ul><li><code>qcvalues</code>: quality check values, one for each data point.</li></ul><p>The higher the value, the more suspect a data point is. Absolute values of <code>qcvalues</code> might be not robust when analysis parameters are uncertain. The ranking is however quite robust.</p><p>If you cannot run <code>DIVAndrun</code> but use <code>DIVAndgo</code> (which does not provide a structure s at the output), the latter provides <code>qcvalues</code> if you call <code>DIVAndgo</code> with a keyword parameter <code>QCMETHOD=</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_qc.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_solve!" href="#DIVAnd.DIVAnd_solve!"><code>DIVAnd.DIVAnd_solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Solve the variational problem.</p><pre><code class="language-none"> fi = DIVAnd_solve(s)</code></pre><p>Derive the analysis based on all contraints included in s and using the observations yo</p><p>Input:   s: structure created by DIVAnd_factorize   fi0: starting point for iterative primal methods   f0: starting point for the iterative dual method</p><p>btrunc: the value at which the stored value of s.iB was truncated and needs to be completed on the fly using jmBix</p><p>Output:   fi: analyzed field</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_solve.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_sampler" href="#DIVAnd.DIVAnd_sampler"><code>DIVAnd.DIVAnd_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samplesteps = DIVAnd_sampler(pmn,len);</code></pre><p><strong>Defines steps for sub-sampling in the discrete grid which would still allow</strong></p><p>one to resolve the provided lengthscales</p><p><strong>Input:</strong></p><ul><li><p><code>pmn</code>: scale factor of the grid. pmn is a tuple with n elements. Every      element represents the scale factor of the corresponding dimension. Its      inverse is the local resolution of the grid in a particular dimension.</p></li><li><p><code>len</code>: correlation length</p></li></ul><p><strong>Output:</strong></p><ul><li><code>samplesteps</code>: vector of integers with steps in subsampling [1 2 4 1] means every grid point in x direction, every fifth in y etc</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_sampler.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAndjog" href="#DIVAnd.DIVAndjog"><code>DIVAnd.DIVAndjog</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute a variational analysis of arbitrarily located observations.</p><pre><code class="language-none"> fi,s = DIVAndjog(mask,pmn,xi,x,f,len,epsilon2,csteps,lmask; alphapc=[1,2,1], otherargs...);</code></pre><p>Perform an n-dimensional variational analysis of the observations <code>f</code> located at the coordinates <code>x</code>. The array <code>fi</code> represent the interpolated field at the grid defined by the coordinates <code>xi</code> and the scales factors <code>pmn</code>.</p><p><strong>Input:</strong></p><ul><li>Same parameters as for divarun.       * Two additional parameters:               * csteps: array of ndims values defining the sampling steps for the preconditionner               * lmask: array of ndims mutilplications factors for length scales       * One additional optional parameter               * alphapc: The coefficients for the norm used in the preconditionner</li></ul><p><strong>Output:</strong></p><ul><li><code>fi</code>: the analysed field</li><li><code>s</code>: structure with an array <code>s.P</code> representing the analysed error covariance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAndjog.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_background_components" href="#DIVAnd.DIVAnd_background_components"><code>DIVAnd.DIVAnd_background_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iB = DIVAnd_background_components(s,D,alpha; kwargs...)</code></pre><p>Form the different components of the background error covariance matrix. Compute the components of the background error covariance matrix <code>s.iB_</code> and their sum based on alpha (the adimensional coefficients for norm, gradient, laplacian,...).</p><p>If the optional arguments contains btrunc, the calculation of iB is limited to the term up and including alpha[btrunc]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_background_components.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.stats" href="#DIVAnd.stats"><code>DIVAnd.stats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">meanx,stdx = stats(sumx,sumx2,N)</code></pre><p>Computes the mean <code>meanx</code> and the standard deviation <code>stdx</code> from the sum (<code>sumx</code>) and the sum of squares (<code>sumx2</code>) from <code>N</code> numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/fit.jl#L1-L6">source</a></section><section><div><pre><code class="language-none">meanx,meany,stdx,stdy,covar,corr = stats(sumx,sumx2,sumy,sumy2,sumxy,N)</code></pre><p>Computes the mean <code>meanx</code> and the standard deviation <code>stdx</code> from the sum (<code>sumx</code>) and the sum of squares (<code>sumx2</code>) from <code>N</code> numbers and similarly for the variable <code>y</code>. The function computes also the Pearson correlation <code>corr</code> and covariance <code>covar</code> between <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/fit.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.statpos" href="#DIVAnd.statpos"><code>DIVAnd.statpos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ulon,ulat = statpos(lon,lat)</code></pre><p>Return unique positions (<code>ulon</code>, <code>ulat</code>) as well their mean, standard deviation and count of the vector of observations <code>val</code> located at the positions <code>lon</code> and <code>lat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/obsstat.jl#L4-L11">source</a></section><section><div><pre><code class="language-none">ulon,ulat,meanval,stdval,count = statpos(val,lon,lat)</code></pre><p>Return unique positions (<code>ulon</code>, <code>ulat</code>) as well as their mean, standard deviation and count of the vector of observations <code>val</code> located at the positions <code>lon</code> and <code>lat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/obsstat.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.blkdiag" href="#DIVAnd.blkdiag"><code>DIVAnd.blkdiag</code></a> — <span class="docstring-category">Function</span></header><section><div><p>concatenate diagonal matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd.jl#L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst" href="#Base.findfirst"><code>Base.findfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findfirst(c::Concept,name,collection)</code></pre><p>Return the first related concepts in the collection <code>collection</code>. <code>name</code> can be the string &quot;related&quot;, &quot;narrower&quot;, &quot;broader&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/Vocab.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.formatsize" href="#DIVAnd.formatsize"><code>DIVAnd.formatsize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>display size as a string </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd.jl#L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.interp!" href="#DIVAnd.interp!"><code>DIVAnd.interp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interp!(xi,fi,x,f)</code></pre><p>Interpolate field <code>fi</code> (n-dimensional array) defined at <code>xi</code> (tuble of n-dimensional arrays or vectors) onto grid <code>x</code> (tuble of n-dimensional arrays). The interpolated field is stored in <code>f</code>. The grid in <code>xi</code> must be align with the axis (e.g. produced by DIVAnd.ndgrid).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L623-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ufill" href="#DIVAnd.ufill"><code>DIVAnd.ufill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cfilled = ufill(c,valex)</code></pre><p>Replace values in <code>c</code> equal to <code>valex</code> by averages of surrounding points. <code>valex</code> should not be NaN; use <code>ufill(c,isfinite.(c))</code> or <code>ufill(c,.!isnan.(c))</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L39-L45">source</a></section><section><div><pre><code class="language-none">ufill(c::Array{T,2},mask::AbstractArray{Bool}) where T</code></pre><p><code>mask</code> is true where <code>c</code> is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.cgradient" href="#DIVAnd.cgradient"><code>DIVAnd.cgradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hx,hy = cgradient(pmn,h)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/utils.jl#L369-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.fzero" href="#DIVAnd.fzero"><code>DIVAnd.fzero</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fzero(f,x0,x1,eps; maxiter = Inf) find the zero of the function f between x0 and x1 assuming x0 &lt; x1 at a precision eps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_kernel.jl#L87-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.localize_separable_grid" href="#DIVAnd.localize_separable_grid"><code>DIVAnd.localize_separable_grid</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Derive fractional indices on a separable grid.</p><pre><code class="language-none">I = localize_separable_grid(xi,mask,x)</code></pre><p>xi is a tuple of vectors and x and tuple of n-dimensional arrays, e.g.</p><p>x1,x2 = ndgrid(2 * collect(1:5),collect(1:6)) x = (x1,x2)</p><p>Derive fractional indices where xi are the points (typical discrete observations) to localize in the separable grid <code>x</code> (every dimension in independent on other dimension). The output <code>I</code> is an n-by-m array where n number of dimensions and m number of observations. The corresponding element of I is negative if <code>xi</code> is outside of the grid defined by <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/localize_separable_grid.jl#L56-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.decompB!" href="#DIVAnd.decompB!"><code>DIVAnd.decompB!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>work1, work2: size of mask</p><p>Symmetric matrix</p><p>SB = √(β) (1 + α L)^(nmax / 2) W^{-1}</p><p>where W is the volumne of the corresponding grid cell. The background error covariance matrix B is SB W SB</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/varanalysis.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.varanalysis" href="#DIVAnd.varanalysis"><code>DIVAnd.varanalysis</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Variational analysis similar to 3D-var</p><p>Input:</p><p>x0: start vector for iteration, at output it is the last state of the    iteration. Note that x0 is related to the analysis xa by       xa = SB^½ * W^½ * xa</p><p>| x + W^½ * SB^½ * H&#39; * (R \ (H * SB^½ * W^½ * x ))   -   W^½ SB^{½} * H&#39; * (R \ yo) |      &lt;   tol * s.sv.n / length(yo)  * | W^½ SB^{½} * H&#39; * (R \ yo) |</p><p>Kernel is the solution of the n-dimensional diffusion equation</p><p>∂c/∂t =  ∇ ⋅ (D ∇ c)</p><p>n-dimensional Green’s function</p><p>G(x,x&#39;,t) = (4πDt)^(-n/2)  exp( - |x -x&#39;|² / (4Dt))</p><p>G(x,x&#39;,t) = det(D)^(-½) (4π t)^(-n/2)  exp( - (x -x&#39;)ᵀ D⁻¹ (x -x&#39;) / (4t))</p><p>http://www.rpgroup.caltech.edu/~natsirt/aph162/diffusion_old.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/varanalysis.jl#L69-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.len_harmonize" href="#DIVAnd.len_harmonize"><code>DIVAnd.len_harmonize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Len = len_harmonise(len,mask)</code></pre><p>Produce a tuple of arrays of the correlation length <code>len</code> which can be either a scalar (homogeneous and isotropic case), a tuple of scalar (homogeneous case) or already a tuple of arrays (general case). The the later case the size of the arrays are veryfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.alpha_default" href="#DIVAnd.alpha_default"><code>DIVAnd.alpha_default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neff, alpha = alpha_default(Labs,alpha)</code></pre><p>Return a default value of alpha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.ncfile" href="#DIVAnd.ncfile"><code>DIVAnd.ncfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DIVAnd_save(ds,filename,xyi,fi,varname;
                  ncvarattrib = Dict(), ncglobalattrib = Dict(), ...)</code></pre><p>Save the result of the analysis in a netCDF file .</p><p><strong>Input arguments</strong></p><ul><li><code>ds</code>: the NetCDF dataset</li><li><code>filename</code>: the name of the NetCDF file</li><li><code>mask</code>: binary mask delimiting the domain. true is inside and false outside. For oceanographic application, this is the land-sea mask where sea is true and land is false.</li><li><code>xyi</code>: tuple with n elements. Every element represents a coordinate of the final grid on which the observations are interpolated</li><li><code>fi</code>: the analysed field</li><li><code>varname</code>: the name of the NetCDF variable</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>ncglobalattrib</code>: a dictionary with the global attributes</li><li><code>ncvarattrib</code>: a dictionary with the variable attributes</li><li><code>relerr</code>: relative error</li><li><code>timeorigin</code>: time origin for the time units attribute (default is 1900-01-01 00:00:00)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_save.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.writeslice" href="#DIVAnd.writeslice"><code>DIVAnd.writeslice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">writeslice(ncvar, ncvar_relerr, ncvar_Lx, fi, relerr, index)</code></pre><p>Write a slice of data in a netCDF file given by the index <code>index</code>. The variable <code>relerr</code> can be nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_save.jl#L347-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.encodeWMSStyle" href="#DIVAnd.encodeWMSStyle"><code>DIVAnd.encodeWMSStyle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>encode parameters as key-value separated by : and +</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/SDNMetadata.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.loadoriginators" href="#DIVAnd.loadoriginators"><code>DIVAnd.loadoriginators</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">db = loadoriginators(fname)</code></pre><p>Load the CDI list from the file <code>fname</code> (zip with a csv file, or csv file directly).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/SDNMetadata.jl#L205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_integral" href="#DIVAnd.DIVAnd_integral"><code>DIVAnd.DIVAnd_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes an N-dimensional volume integral</p><p>DIVAnd_integral(mask,pmn,fieldin)</p><p><strong>Input:</strong></p><ul><li><code>mask</code>: mask as usual</li><li><code>pmn</code> : tuple of metrics as usual</li><li><code>fieldin</code>: field of the same dimensions as mask and which is integrated over the domain</li></ul><p><strong>Output:</strong></p><ul><li><code>integratedfield</code>: The integral</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_integral.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DIVAnd.DIVAnd_scaleL" href="#DIVAnd.DIVAnd_scaleL"><code>DIVAnd.DIVAnd_scaleL</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes a relative length based on the mask, metrics and a density field, typically measuring the observation density calculated with DIVAnd_heatmap</p><p>lambda = DIVAnd_scaleL(mask,pmn,dens)</p><p><strong>Input:</strong></p><ul><li><code>mask</code>: mask as usual</li><li><code>pmn</code> : tuple of metrics as usual</li><li><code>dens</code>: field of the same dimensions as mask. Higher values of dens will result in lower values of lambda.</li></ul><p><strong>Output:</strong></p><ul><li><code>lambda</code>: field to be applied to a reference length field. Values are around 1 so some regions will have smaller L and some higher L</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gher-ulg/DIVAnd.jl/blob/096654bf82350dc544a7d6704bc1c1b9e92331e4/src/DIVAnd_scaleL.jl#L1-L16">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>To run the example, you need to install <code>PyPlot</code>. In the folder <code>examples</code> of DIVAnd, you can run e.g. the example <code>DIVAnd_simple_example_1D.jl</code> by issuing:</p><pre><code class="language-julia"># cd(&quot;/path/to/DIVAnd/examples&quot;)
include(&quot;test/DIVAnd_simple_example_1D.jl&quot;)</code></pre><p>Replace <code>/path/to/DIVAnd/</code> by the installation directory of DIVAnd which is the output of the following code:</p><pre><code class="language-julia">using DIVAnd;
joinpath(dirname(pathof(DIVAnd)), &quot;..&quot;)</code></pre><h3 id="Advection-constraint"><a class="docs-heading-anchor" href="#Advection-constraint">Advection constraint</a><a id="Advection-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Advection-constraint" title="Permalink"></a></h3><p>The functions <code>DIVAndrun</code>, <code>DIVAndgo</code> and <code>diva3d</code> can also use an advection constraint forcing the analysis to align with a vector field (e.g. a velocity field). The velocity field should be a tuple of n-elements. Every element of the tuple is a gridded array (defined at the same location than the target array) representing a single velocity component. For 3D analysis, the order of the dimensions is typically: longitude, latitude and depth. Like-wise the velocity components are zonal, meridional and vertical velocity. The three velocity components has to be scaled by a constant factor to enhance or decrease this constraint. It is recommended that this parameter is tuned by cross-validation. There are no tools currently in DIVAnd.jl to automate this process.</p><p>For the two dimensional case, the velocity has just two components as shown in the example below.</p><pre><code class="language-">using DIVAnd, PyPlot

# square domain in 2 dimensions from -1 to 1
mask, (pm, pn), (xi, yi) = DIVAnd_squaredom(2, range(-1, stop = 1, length = 30))

# location of the observations
x = [.4]
y = [.4]

# observed value
f = [1.]

# velocity field and its strength for the advection constrain
strength = 0.5
u = strength * yi
v = -strength * xi

# normalized obs. error variance and correlation length
epsilon2 = 1 / 200
len = 0.2

# call DIVAnd
fi, s = DIVAndrun(mask,(pm,pn),(xi,yi),(x,y),f,len,epsilon2; velocity = (u,v))

# plot the results
subplot(1,2,1)
plot(x,y,&quot;rx&quot;)
quiver(xi,yi,u,v)
gca().set_aspect(1)
title(&quot;velocity field&quot;)

subplot(1,2,2)
plot(x,y,&quot;rx&quot;)
pcolor(xi,yi,fi)
gca().set_aspect(1)
title(&quot;analysis&quot;)
savefig(&quot;example-advection-2d.png&quot;); nothing # hide</code></pre><p><img src="example-advection-2d.png" alt/></p><h2 id="Performance-considerations"><a class="docs-heading-anchor" href="#Performance-considerations">Performance considerations</a><a id="Performance-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-considerations" title="Permalink"></a></h2><h3 id="Tuning-the-domain-decomposition"><a class="docs-heading-anchor" href="#Tuning-the-domain-decomposition">Tuning the domain decomposition</a><a id="Tuning-the-domain-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-the-domain-decomposition" title="Permalink"></a></h3><p>The functions <code>diva3d</code> and <code>DIVAndgo</code> split the domain into overlapping sub-domains to reduce the required amount of memory. In some circumstances (in particular few vertical levels), this can unnecessarily degrade the performance. The CPU time of the analysis can be improved by increasing the <code>diva3d</code> option <code>memtofit</code> from 3 (default) to higher values (as long as one does not run out of memory). If this parameter is set to a very high value then the domain decomposition is effectively disabled.</p><h3 id="Multiple-CPU-system"><a class="docs-heading-anchor" href="#Multiple-CPU-system">Multiple CPU system</a><a id="Multiple-CPU-system-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-CPU-system" title="Permalink"></a></h3><p>Per default Julia tries to use all CPUs on your system when doing matrix operations. The number of CPUs is controlled by the call to <code>BLAS.set_num_threads</code>. Using multiple CPUs can result in overhead and it can be beneficial to reduce the number of CPUs:</p><pre><code class="language-julia">BLAS.set_num_threads(2)</code></pre><h2 id="Debugging-message"><a class="docs-heading-anchor" href="#Debugging-message">Debugging message</a><a id="Debugging-message-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-message" title="Permalink"></a></h2><p>From Julia 1.0 on, debugging messages can be activated using the following Julia command:</p><pre><code class="language-julia">ENV[&quot;JULIA_DEBUG&quot;] = &quot;DIVAnd&quot;</code></pre><p>See also https://docs.julialang.org/en/v1/stdlib/Logging/index.html#Environment-variables-1 .</p><h2 id="Correlation-length"><a class="docs-heading-anchor" href="#Correlation-length">Correlation length</a><a id="Correlation-length-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-length" title="Permalink"></a></h2><p>The estimation of the correlation length in the function <code>diva3d</code> can be activated with the option <code>fitcorrlen</code> for the horizontal and vertical correlation. The parameter <code>len</code> should then an empty tuple (<code>()</code>) or a tuple of arrays equal to one. The actually used correlation length is a product between the provided values of the array <code>len</code> and the estimated correlation length by fitting. Setting <code>fitcorrlen</code> to true means thus that the interpretation of the parameters changes from absolution correlation length to relative correlation length.</p><p>The estimation of the horizontal and vertical correlation can also be activated selectively by just setting <code>fithorzcorrlen</code> and <code>fitvertcorrlen</code> (respectively) to true.</p><p>If one wants to not use the vertical correlation length, the one can put the corresponding value in <code>len</code> to zero. Consequently the value of <code>fitvertcorrlen</code> and <code>fitcorrlen</code> should be keep to <code>false</code> (i.e. its default values). Optimizing the horizontal correlation length is still possible by setting <code>fithorzcorrlen</code> to <code>true</code>.</p><h2 id="Integrating-different-datasets"><a class="docs-heading-anchor" href="#Integrating-different-datasets">Integrating different datasets</a><a id="Integrating-different-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Integrating-different-datasets" title="Permalink"></a></h2><p>To facilitated the integrating of different datasets, the function <code>WorldOceanDatabase.load</code> from the module <code>PhysOcean</code> now supports an option <code>prefixid</code> which can be set to <code>&quot;1977-&quot;</code> so that the obsids have automatically the right format for DIVAnd, e.g. <code>&quot;1977-wod123456789O&quot;</code>:</p><pre><code class="language-julia">using PhysOcean
# assuming the data in the directory &quot;somedir&quot;: e.g. &quot;somedir/CTD/file.nc&quot;, &quot;somedir/XBT/file.nc&quot;...
basedir = &quot;somedir&quot;
varname = &quot;Temperature&quot;
prefixid = &quot;1977-&quot;
obsvalue,obslon,obslat,obsdepth,obstime,obsid = WorldOceanDatabase.load(Float64,
   basedir,varname; prefixid = prefixid);</code></pre><p>In the module <code>PhysOcean</code>, we implemented the function ARGO.load which can load data following the ARGO format and in particular the CORA dataset. In fact, even if CORA is distributed through CMEMS, the netCDF files in CORA do not follow the same format than the other in situ netCDF files from CMEMS. Therefore the function <code>CMEMS.load</code> can not be used for the CORA dataset. <code>ARGO.load</code> also supports the option prefixid.</p><pre><code class="language-julia">using Glob, PhysOcean
# assuming the data in the directory &quot;somedir&quot;: e.g. &quot;somedir/someyear/file.nc&quot;
filenames = glob(&quot;*/*nc&quot;,&quot;somedir&quot;)
obsvalue,obslon,obslat,obsdepth,obstime,obsids = ARGO.load(Float64,
   filenames,varname; prefixid = &quot;4630-&quot;)</code></pre><p>In divadoxml we added the new argument additionalcontacts which allows one to acknowledge other datasets which are not in the MARIS database:</p><pre><code class="language-julia">using DIVAnd
additionalcontacts = [
    DIVAnd.getedmoinfo(1977,&quot;originator&quot;), # US NODC for World Ocean Database
    DIVAnd.getedmoinfo(4630,&quot;originator&quot;), # CORIOLIS for CORA
]
ignore_errors = true
DIVAnd.divadoxml(
           filename,varname,project,cdilist,xmlfilename,
           ignore_errors = ignore_errors,
           additionalcontacts = additionalcontacts
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You will see a warning that not all observation identifiers could be found, but this is normal and expected.</p></div></div><h2 id="Frequently-asked-questions"><a class="docs-heading-anchor" href="#Frequently-asked-questions">Frequently asked questions</a><a id="Frequently-asked-questions-1"></a><a class="docs-heading-anchor-permalink" href="#Frequently-asked-questions" title="Permalink"></a></h2><h3 id="Which-data-points-are-used-for-the-analysis?"><a class="docs-heading-anchor" href="#Which-data-points-are-used-for-the-analysis?">Which data points are used for the analysis?</a><a id="Which-data-points-are-used-for-the-analysis?-1"></a><a class="docs-heading-anchor-permalink" href="#Which-data-points-are-used-for-the-analysis?" title="Permalink"></a></h3><p>An individual data point is used if all following conditions are met:</p><ol><li>longitude/latitude is inside the domain and not adjacent to a land point</li><li>the depth is within the depth range of the domain</li><li>the time is within the temporal range</li><li>if an <em>anamorphosis</em> transform is used, it should correspond to a finite transformed value</li><li>during the loading, the corresponding quality flag is among the accepted quality flags</li></ol><p>Note that for points 1.-3. the finite precision of floating point numbers can affect the results.</p><h3 id="How-to-resolve-a-bias-of-the-surface-layer-(or-the-deepest-layer)?"><a class="docs-heading-anchor" href="#How-to-resolve-a-bias-of-the-surface-layer-(or-the-deepest-layer)?">How to resolve a bias of the surface layer (or the deepest layer)?</a><a id="How-to-resolve-a-bias-of-the-surface-layer-(or-the-deepest-layer)?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-resolve-a-bias-of-the-surface-layer-(or-the-deepest-layer)?" title="Permalink"></a></h3><p>In DIVAnd, the vertical levels must resolve the vertical correlation length. If the vertical correlation length is smaller than the surface resolution, this can result in a bias of the surface value. A similar problem can also be present at the deepest layer. The solution is to either refine the vertical resolution or to increase the vertical correlation length.</p><h3 id="How-do-I-limit-the-estimated-horizontal-and-vertical-correlation-length-in-DIVAnd?"><a class="docs-heading-anchor" href="#How-do-I-limit-the-estimated-horizontal-and-vertical-correlation-length-in-DIVAnd?">How do I limit the estimated horizontal and vertical correlation length in DIVAnd?</a><a id="How-do-I-limit-the-estimated-horizontal-and-vertical-correlation-length-in-DIVAnd?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-limit-the-estimated-horizontal-and-vertical-correlation-length-in-DIVAnd?" title="Permalink"></a></h3><p>It can be necessary to limit the estimated correlation length to an acceptable range. The function (called <code>limitfun</code>) can be applied to the estimated correlation to make such adjustment. This function takes as arguments the estimated correlation length and the depth and returns the adjusted correlation length. For example the following function forces the horizontal correlation length to be between 50 km and 200 km (independently of the depth).</p><pre><code class="language-julia"># len and z are expressed in meters
function mylimitfun(z,len)
   if len &gt; 200_000
      return 200_000
   end
   if len &lt; 50_000
      return 50_000
   end
   return len
end</code></pre><p>(<code>200_000</code> is just a more readable way to write <code>200000</code>). This function is used in <code>diva3d</code> as follow:</p><pre><code class="language-julia">... = diva3d(...
   fithorz_param = Dict(:limitfun =&gt; mylimitfun)</code></pre><p>The same can be achieved more compactly as follows:</p><pre><code class="language-julia">... = diva3d(...
   fithorz_param = Dict(:limitfun =&gt; (z,len) -&gt; min(max(len,50_000),200_000)),
   fitvert_param = Dict(:limitfun =&gt; (z,len) -&gt; min(max(len,20),200)))</code></pre><p>A similar option has also be added for the vertical correlation length.</p><h3 id="How-do-I-reduce-the-estimated-correlation-length-near-the-coast-when-it-is-estimated-internally?"><a class="docs-heading-anchor" href="#How-do-I-reduce-the-estimated-correlation-length-near-the-coast-when-it-is-estimated-internally?">How do I reduce the estimated correlation length near the coast when it is estimated internally?</a><a id="How-do-I-reduce-the-estimated-correlation-length-near-the-coast-when-it-is-estimated-internally?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-reduce-the-estimated-correlation-length-near-the-coast-when-it-is-estimated-internally?" title="Permalink"></a></h3><p>The actual used correlation lengths is the product between the estimated one (by fitting) and the arrays in the parameter <code>len</code> (if provided). The function <code>lengraddepth</code> can be used to create a reduced correlation length near the bathymetry. (https://github.com/gher-ulg/Diva-Workshops/blob/master/notebooks/5-AdvancedTopics/17-relative-correlation-length.ipynb)</p><h3 id="How-can-I-handle-data-set-of-very-different-resolution?"><a class="docs-heading-anchor" href="#How-can-I-handle-data-set-of-very-different-resolution?">How can I handle data set of very different resolution?</a><a id="How-can-I-handle-data-set-of-very-different-resolution?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-handle-data-set-of-very-different-resolution?" title="Permalink"></a></h3><p>If data from a high-resolution dataset (e.g. profiling float, dense time series) is combined with data with a low spatial resolution (e.g. profiles from a research vessel), then the analysis can be biased toward the high-resolution data. The function <code>weight_RtimesOne(x,len)</code> can be used to reduce the weight of the high-resolution data (https://github.com/gher-ulg/Diva-Workshops/blob/master/notebooks/13-processing-parameter-optimization.ipynb). Alternative methods are averaging data in bins (&quot;binning&quot;) or simply sub-sampling the data.</p><h3 id="My-parameter-represent-a-concentration-and-I-get-unrealistic-negative-values"><a class="docs-heading-anchor" href="#My-parameter-represent-a-concentration-and-I-get-unrealistic-negative-values">My parameter represent a concentration and I get unrealistic negative values</a><a id="My-parameter-represent-a-concentration-and-I-get-unrealistic-negative-values-1"></a><a class="docs-heading-anchor-permalink" href="#My-parameter-represent-a-concentration-and-I-get-unrealistic-negative-values" title="Permalink"></a></h3><ul><li>You can use an anamorphosis transform, in particular <code>DIVAnd.Anam.loglin</code>. The idea is that the transformed variable is closer to a Gaussian distribution that the original variable.</li><li>Use the option <code>fieldmin = 0.0</code> of <code>diva3d</code></li></ul><p>If the parameter <code>epsilon</code> of <code>DIVAnd.Anam.loglin</code> is larger than zero (which is necessary if some measurements are exactly zero), then the smallest value that analysis can have is <code>-epsilon</code>. Therefore the option <code>fieldmin</code> is still required to avoid negative values.</p><h3 id="How-can-I-speed-up-analysis-using-observations-which-always-have-the-same-coordinates?"><a class="docs-heading-anchor" href="#How-can-I-speed-up-analysis-using-observations-which-always-have-the-same-coordinates?">How can I speed up analysis using observations which always have the same coordinates?</a><a id="How-can-I-speed-up-analysis-using-observations-which-always-have-the-same-coordinates?-1"></a><a class="docs-heading-anchor-permalink" href="#How-can-I-speed-up-analysis-using-observations-which-always-have-the-same-coordinates?" title="Permalink"></a></h3><p>In this situation, the measurements are always done at the same locations, but the measurements are repeated over time or different variables are measured at those positions. It is possible to take into the already computed matrices so that the subsequent analysis can be executed much faster.</p><p>Let&#39;s assume the observations are available on <code>np</code> locations and repeated <code>nt</code> times, so that <code>obsval</code> is an array of size <code>np X nt</code>.</p><p>The first analysis is performed using:</p><pre><code class="language-julia">@time fi1,s = DIVAndrun((mask),(pm,pn),
    (xi,yi),(obslon,obslat),Float64.(obsval[:,1]),len,epsilon2);</code></pre><p>then, for the <code>nt</code> other analysis, we use the structure <code>s</code>, computed in the previous step, as follows:</p><pre><code class="language-julia">fpi = s.P * (s.H&#39; * (s.R \ obsval[:,i]))
f_with_mask = unpack(s.sv, fpi, NaN)</code></pre><p>where i=1, ..., nt.      </p><p>The <code>unpack</code> function <em>unpacks</em> the vector <code>fpi</code> into the different variables var1, var2, ... <code>s.sv</code> is the statevector and <code>NaN</code> is the fill value.</p><p>Check the <a href="https://github.com/gher-ulg/DIVAnd.jl/blob/master/examples/DIVAnd_example_fixed_obs.jl">example</a>.</p><h2 id="API-changes"><a class="docs-heading-anchor" href="#API-changes">API changes</a><a id="API-changes-1"></a><a class="docs-heading-anchor-permalink" href="#API-changes" title="Permalink"></a></h2><p>We do our best to avoid changing the API, but sometimes it is unfortunately necessary.</p><ul><li>2019-06-24: <code>DIVAnd.fit_isotropic</code> and <code>DIVAnd.fit</code> are removed and replaced by <code>DIVAnd.fithorzlen</code> and <code>DIVAnd.fitvertlen</code>.</li><li>2019-06-24: If the parameters <code>background_lenz</code> and <code>background_lenz_factor</code> of <code>diva3d</code> are both specified, then preference will now be given for <code>background_lenz</code>.</li><li>2018-07-02: The module <code>divand</code> has been renamed <code>DIVAnd</code> and likewise functions containing <code>divand</code></li><li>2018-06-18: The options <code>nmean</code> and <code>distbin</code> of <code>fithorzlen</code> and <code>fitvertlen</code> have been removed. The functions now choose appropriate values for these parameters automatically.</li></ul><h2 id="Information-for-developers"><a class="docs-heading-anchor" href="#Information-for-developers">Information for developers</a><a id="Information-for-developers-1"></a><a class="docs-heading-anchor-permalink" href="#Information-for-developers" title="Permalink"></a></h2><p>To update the documentation locally, install the package <code>Documenter</code> and run the script <code>include(&quot;docs/make.jl&quot;)</code>.</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;Documenter&quot;)</code></pre><h2 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h2><p>If the installation of a package fails, it is recommended to update the local copy of the package list by issuing <code>Pkg.update()</code> to make sure that Julia knows about the latest version of these packages and then to re-try the installation of the problematic package. Julia calls the local copy of the package list <code>METADATA</code>. For example to retry the installation of <code>EzXML</code> issue the following command:</p><pre><code class="language-julia">using Pkg
Pkg.update()
Pkg.add(&quot;EzXML&quot;)</code></pre><h3 id="Installation-problem-of-PyPlot-on-Linux-(Debian/Ubuntu)"><a class="docs-heading-anchor" href="#Installation-problem-of-PyPlot-on-Linux-(Debian/Ubuntu)">Installation problem of PyPlot on Linux (Debian/Ubuntu)</a><a id="Installation-problem-of-PyPlot-on-Linux-(Debian/Ubuntu)-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-problem-of-PyPlot-on-Linux-(Debian/Ubuntu)" title="Permalink"></a></h3><p>Make sure that the following Debian/Ubuntu packages are installed:</p><pre><code class="language-bash">sudo apt-get install python3 libpython3 python3-tk</code></pre><p>Then start Julia and run:</p><pre><code class="language-none">using Pkg
Pkg.build(&quot;PyCall&quot;)
Pkg.build(&quot;PyPlot&quot;)</code></pre><p>Test PyPlot with:</p><pre><code class="language-julia">using PyPlot
plot(1:10)</code></pre><h3 id="No-plotting-window-appears"><a class="docs-heading-anchor" href="#No-plotting-window-appears">No plotting window appears</a><a id="No-plotting-window-appears-1"></a><a class="docs-heading-anchor-permalink" href="#No-plotting-window-appears" title="Permalink"></a></h3><p>If the following command doesn&#39;t produce any figure</p><pre><code class="language-julia">using PyPlot
plot(1:10)</code></pre><p>A possible solution is to modify the <em>backend</em>: this is done by editing the python configuration file <a href="http://matplotlib.org/users/customizing.html#the-matplotlibrc-file">matplotlibrc</a>. The location of this file is obtained in python with:</p><pre><code class="language-python">import matplotlib
matplotlib.matplotlib_fname</code></pre><p>Under Linux, this returns <code>&#39;~/.config/matplotlib/matplotlibrc&#39;</code>. To use the <code>TkAgg</code> backend, add the following to the file:</p><pre><code class="language-none">backend      : TkAgg</code></pre><p>The <code>matplotlibrc</code> need to be created if it does not exists.</p><h3 id="C-runtime-library-when-calling-PyPlot"><a class="docs-heading-anchor" href="#C-runtime-library-when-calling-PyPlot">C runtime library when calling PyPlot</a><a id="C-runtime-library-when-calling-PyPlot-1"></a><a class="docs-heading-anchor-permalink" href="#C-runtime-library-when-calling-PyPlot" title="Permalink"></a></h3><p><code>R6034 an application has made an attempt to load the C runtime library incorrectly</code> on Windows 10 with julia 0.6.1, matplotlib 2.1.0, PyPlot 2.3.2:</p><pre><code class="language-julia">ENV[&quot;MPLBACKEND&quot;]=&quot;qt4agg&quot;</code></pre><p>You can put this line in a file <code>.juliarc.jl</code> placed in your home directory (the output of <code>homedir()</code> in Julia).</p><h3 id="Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012"><a class="docs-heading-anchor" href="#Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012">Julia cannot connect to GitHub on Windows 7 and Windows Server 2012</a><a id="Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-cannot-connect-to-GitHub-on-Windows-7-and-Windows-Server-2012" title="Permalink"></a></h3><p>Cloning METADATA or downloading a Julia packages fails with:</p><pre><code class="language-none">GitError(Code:ECERTIFICATE, Class:OS, , user cancelled certificate checks: )</code></pre><p>The problem is that Windows 7 and Windows Server 2012 uses outdated encryption protocols. The solution is to run the &quot;Easy fix&quot; tool from the <a href="https://stackoverflow.com/questions/49065986/installation-of-julia-on-windows7-64-bit">Microsoft support page</a></p><h3 id="MbedTLS.jl-does-not-install-on-Windows-7"><a class="docs-heading-anchor" href="#MbedTLS.jl-does-not-install-on-Windows-7">MbedTLS.jl does not install on Windows 7</a><a id="MbedTLS.jl-does-not-install-on-Windows-7-1"></a><a class="docs-heading-anchor-permalink" href="#MbedTLS.jl-does-not-install-on-Windows-7" title="Permalink"></a></h3><p>The installation of <code>MbedTLS.jl</code> fails with the error message:</p><pre><code class="language-none">INFO: Building MbedTLS
Info: Downloading https://github.com/quinnj/MbedTLSBuilder/releases/download/v0.6/MbedTLS.x86_64-w64-mingw32.tar.gz to C:\Users\Jeremy\.julia\v0.6\MbedTLS
\deps\usr\downloads\MbedTLS.x86_64-w64-mingw32.tar.gz...
Exception setting &quot;SecurityProtocol&quot;: &quot;Cannot convert null to type &quot;System.Net.SecurityProtocolType&quot; due to invalid enumeration values. Specify one of th
e following enumeration values and try again. The possible enumeration values are &quot;Ssl3, Tls&quot;.&quot;
At line:1 char:35
+ [System.Net.ServicePointManager]:: &lt;&lt;&lt;&lt; SecurityProtocol =
    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException
    + FullyQualifiedErrorId : PropertyAssignmentException
    [...]</code></pre><p>See also the issue <a href="https://github.com/JuliaWeb/MbedTLS.jl/issues/133">https://github.com/JuliaWeb/MbedTLS.jl/issues/133</a>.</p><p>The solution is to install the <a href="https://www.microsoft.com/en-us/download/details.aspx?id=40855">Windows Management Framework 4.0</a>.</p><h3 id="EzXML.jl-cannot-be-installed-on-RedHat-6"><a class="docs-heading-anchor" href="#EzXML.jl-cannot-be-installed-on-RedHat-6">EzXML.jl cannot be installed on RedHat 6</a><a id="EzXML.jl-cannot-be-installed-on-RedHat-6-1"></a><a class="docs-heading-anchor-permalink" href="#EzXML.jl-cannot-be-installed-on-RedHat-6" title="Permalink"></a></h3><p>The <code>zlib</code> library of RedHat 6, is slightly older than the library which <code>EzXML.jl</code> and <code>libxml2</code> requires.</p><p>To verify this issue, you can type in Julia</p><pre><code class="language-none">using Libdl
using Pkg
Libdl.dlopen(joinpath(Pkg.dir(&quot;EzXML&quot;),&quot;deps/usr/lib/libxml2.so&quot;))</code></pre><p>It should not return an error message. On Redhat 6.6, the following error message is returned:</p><pre><code class="language-none">ERROR: could not load library &quot;/home/username/.../EzXML/deps/usr/lib/libxml2.so&quot;

/lib64/libz.so.1: version `ZLIB_1.2.3.3&#39; not found (required by /home/.../EzXML/deps/usr/lib/libxml2.so)

Stacktrace:

 [1] dlopen(::String, ::UInt32) at ./libdl.jl:97 (repeats 2 times)</code></pre><p>A newer version <code>zlib</code> can be installed by the following command:</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;CodecZlib&quot;)</code></pre><p>However, the following command should work:</p><pre><code class="language-julia"> LD_LIBRARY_PATH=&quot;$HOME/.julia/full/path/to/CodecZlib/.../deps/usr/lib/:$LD_LIBRARY_PATH&quot; julia --eval  &#39;print(Libdl.dlopen(joinpath(Pkg.dir(&quot;EzXML&quot;),&quot;deps/usr/lib/libxml2.so&quot;))&#39;</code></pre><p>by replacing the file path appropriately. (see also <a href="https://github.com/JuliaLang/julia/issues/7004">https://github.com/JuliaLang/julia/issues/7004</a>, <a href="https://github.com/JuliaIO/HDF5.jl/issues/97">https://github.com/JuliaIO/HDF5.jl/issues/97</a>, and <a href="https://github.com/bicycle1885/EzXML.jl/issues/102">https://github.com/bicycle1885/EzXML.jl/issues/102</a>)</p><p>To make Julia use this library, a user on RedHat 6 should always start Julia with:</p><pre><code class="language-bash">LD_LIBRARY_PATH=&quot;$HOME/.julia/full/path/to/CodecZlib/.../deps/usr/lib/:$LD_LIBRARY_PATH&quot; julia</code></pre><p>One can also create script with the following content:</p><pre><code class="language-bash">#!/bin/bash
export LD_LIBRARY_PATH=&quot;$HOME/.julia/full/path/to/CodecZlib/.../deps/usr/lib/:$LD_LIBRARY_PATH&quot;
exec /path/to/bin/julia &quot;$@&quot;</code></pre><p>by replacing <code>/path/to/bin/julia</code> to the full path of your installation directory. The script should be marked executable and it can be included in your Linux search <a href="http://www.linfo.org/path_env_var.html"><code>PATH</code> environment variable</a>. Julia can then be started by calling directly this script.</p><h3 id="The-DIVAnd-test-suite-fails-with-automatic-download-failed"><a class="docs-heading-anchor" href="#The-DIVAnd-test-suite-fails-with-automatic-download-failed">The DIVAnd test suite fails with <code>automatic download failed</code></a><a id="The-DIVAnd-test-suite-fails-with-automatic-download-failed-1"></a><a class="docs-heading-anchor-permalink" href="#The-DIVAnd-test-suite-fails-with-automatic-download-failed" title="Permalink"></a></h3><p>Running <code>using Pkg; Pkg.test(&quot;DIVAnd&quot;)</code> fails with the error:</p><pre><code class="language-julia">automatic download failed (error: 2147500036)</code></pre><p>The test suite will download some sample data. You need to have internet access and run the test function from a directory with write access.</p><p>You can change the directory to your home directory with the Julia command <code>cd(homedir())</code>.</p><p>You can check the current working directory with:</p><pre><code class="language-julia">pwd()</code></pre><h3 id="Convert-error-in-DIVAnd_obs"><a class="docs-heading-anchor" href="#Convert-error-in-DIVAnd_obs">Convert error in <code>DIVAnd_obs</code></a><a id="Convert-error-in-DIVAnd_obs-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-error-in-DIVAnd_obs" title="Permalink"></a></h3><p>The full error message:</p><pre><code class="language-none">MethodError: Cannot `convert` an object of type DIVAnd.DIVAnd_constrain{Float32,Diagonal{Float64},SparseMatrixCSC{Float64,Int64}} to an object of type DIVAnd.DIVAnd_constrain{Float64,TR,TH} where TH&lt;:(AbstractArray{#s370,2} where #s370&lt;:Number) where TR&lt;:(AbstractArray{#s371,2} where #s371&lt;:Number)
This may have arisen from a call to the constructor DIVAnd.DIVAnd_constrain{Float64,TR,TH} where TH&lt;:(AbstractArray{#s370,2} where #s370&lt;:Number) where TR&lt;:(AbstractArray{#s371,2} where #s371&lt;:Number)(...),
since type constructors fall back to convert methods.</code></pre><p>The solution is to use the same type of all input parameters: all Float32 or all Float64.</p><h3 id="Monthlist-issue"><a class="docs-heading-anchor" href="#Monthlist-issue">Monthlist issue</a><a id="Monthlist-issue-1"></a><a class="docs-heading-anchor-permalink" href="#Monthlist-issue" title="Permalink"></a></h3><p>Using comments inside list can lead to unexpected results.</p><p>This</p><pre><code class="language-julia"> monthlist = [
       [1,2,3]
       #[4,5,6]
       ]</code></pre><p>should be written as</p><pre><code class="language-julia"> monthlist = [
       [1,2,3]
       ]</code></pre><h3 id="Error-in-the-factorisation"><a class="docs-heading-anchor" href="#Error-in-the-factorisation">Error in the factorisation</a><a id="Error-in-the-factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#Error-in-the-factorisation" title="Permalink"></a></h3><p>The error message <code>Base.LinAlg.PosDefException(95650)</code> followed by the stack-trace below might be due to a wrong choice in the analysis parameters, for example a too long correlation length.</p><pre><code class="language-none">Stacktrace:
 [1] #cholfact!#8(::Float64, ::Function, ::Base.SparseArrays.CHOLMOD.Factor{Float64}, ::Base.SparseArrays.CHOLMOD.Sparse{Float64}) at ./sparse/cholmod.jl:1360
 .................
 [9] DIVAndrun(::BitArray{3}, ::Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}, ::Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}, ::Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}, ::Array{Float64,1}, ::Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}, ::Float64) at /home/ctroupin/.julia/v0.6/DIVAnd/src/DIVAndrun.jl:147</code></pre><h3 id="Installing-additional-packages-when-using-a-git-clone"><a class="docs-heading-anchor" href="#Installing-additional-packages-when-using-a-git-clone">Installing additional packages when using a git clone</a><a id="Installing-additional-packages-when-using-a-git-clone-1"></a><a class="docs-heading-anchor-permalink" href="#Installing-additional-packages-when-using-a-git-clone" title="Permalink"></a></h3><p>If <code>DIVAnd</code> is installed without the package manager, it can be necessary to install additional packages. This will be explicitly shown, for example:</p><pre><code class="language-none">LoadError: ArgumentError: Module Roots not found in current path.
Run `Pkg.add(&quot;Roots&quot;)` to install the Roots package.</code></pre><h3 id="Kernel-not-working-with-IJulia/Jupyter-under-Julia-0.7-Windows"><a class="docs-heading-anchor" href="#Kernel-not-working-with-IJulia/Jupyter-under-Julia-0.7-Windows">Kernel not working with IJulia/Jupyter under Julia 0.7 Windows</a><a id="Kernel-not-working-with-IJulia/Jupyter-under-Julia-0.7-Windows-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-not-working-with-IJulia/Jupyter-under-Julia-0.7-Windows" title="Permalink"></a></h3><p>Try these commands</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;ZMQ&quot;)
Pkg.add(&quot;IJulia&quot;)
Pkg.update()</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 27 November 2020 07:16">Friday 27 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
